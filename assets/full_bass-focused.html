<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TRI v6.0 OPERATIONAL ‚Ä¢ Learning Engine</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;600&display=swap');
    
    :root {
        --void: #000000;
        --deep: #0a0e27;
        --card: #111827;
        --electric: #00f0ff;
        --neon: #ff006e;
        --gold: #ffd60a;
        --success: #00ff88;
        --danger: #ef4444;
        --warning: #fbbf24;
        --info: #3b82f6;
        --border: #1e293b;
        --text: #e0e7ff;
        --glow: rgba(0, 240, 255, 0.4);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
        background: radial-gradient(ellipse at top, var(--deep), var(--void));
        color: var(--text);
        font-family: 'JetBrains Mono', monospace;
        min-height: 100vh;
        padding: 20px;
        position: relative;
        overflow-x: hidden;
    }

    body::before {
        content: '';
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: 
            repeating-linear-gradient(0deg, rgba(0,240,255,0.03) 0px, transparent 1px, transparent 2px, rgba(0,240,255,0.03) 3px),
            repeating-linear-gradient(90deg, rgba(0,240,255,0.03) 0px, transparent 1px, transparent 2px, rgba(0,240,255,0.03) 3px);
        pointer-events: none;
        z-index: 0;
    }

    .container {
        max-width: 1800px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
    }

    h1 {
        font-family: 'Orbitron', monospace;
        font-size: 2.8rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 40px;
        background: linear-gradient(135deg, var(--electric), var(--neon), var(--gold));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-transform: uppercase;
        letter-spacing: 5px;
        animation: titlePulse 4s ease-in-out infinite;
    }

    @keyframes titlePulse {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.3); }
    }

    .version {
        display: block;
        font-size: 0.7rem;
        color: var(--electric);
        margin-top: 8px;
        letter-spacing: 2px;
    }

    .mode-selector {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-bottom: 30px;
    }

    .mode-btn {
        padding: 15px 30px;
        border: 2px solid var(--border);
        border-radius: 12px;
        background: rgba(17, 24, 39, 0.6);
        color: var(--text);
        font-family: 'Orbitron', monospace;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .mode-btn:hover {
        border-color: var(--electric);
        box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
        transform: translateY(-2px);
    }

    .mode-btn.active {
        border-color: var(--success);
        background: rgba(0, 255, 136, 0.15);
        color: var(--success);
        box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
    }

    .tri-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-bottom: 20px;
    }

    .tri-block {
        background: rgba(17, 24, 39, 0.6);
        backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        position: relative;
        transition: all 0.3s;
        overflow: hidden;
    }

    .tri-block::before {
        content: '';
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 2px;
        background: linear-gradient(90deg, transparent, var(--electric), transparent);
        opacity: 0;
        transition: opacity 0.3s;
    }

    .tri-block:hover {
        border-color: var(--electric);
        transform: translateY(-4px);
        box-shadow: 0 10px 30px -5px var(--glow);
    }

    .tri-block:hover::before { opacity: 1; }

    .tri-title {
        font-family: 'Orbitron', monospace;
        font-size: 0.7rem;
        color: var(--electric);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 240, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .tri-value {
        font-family: 'Orbitron', monospace;
        font-size: 2.5rem;
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 20px rgba(255, 214, 10, 0.5);
        min-height: 3rem;
        display: flex;
        align-items: center;
    }

    .info-label {
        font-size: 0.75rem;
        color: #94a3b8;
        margin-top: 10px;
    }

    .info-data {
        color: var(--electric);
        font-weight: 600;
    }

    .db-panel {
        grid-column: span 4;
        background: rgba(17, 24, 39, 0.8);
        border: 2px solid var(--info);
        border-radius: 16px;
        padding: 25px;
        margin-bottom: 20px;
    }

    .song-list {
        max-height: 400px;
        overflow-y: auto;
        margin-top: 15px;
    }

    .song-item {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 10px;
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 1fr auto;
        gap: 15px;
        align-items: center;
        transition: all 0.3s;
    }

    .song-item:hover {
        border-color: var(--electric);
        background: rgba(0, 240, 255, 0.05);
    }

    .song-title {
        font-weight: 700;
        color: var(--gold);
    }

    .song-artist {
        font-size: 0.85rem;
        color: #94a3b8;
    }

    .song-key {
        color: var(--success);
        font-weight: 600;
    }

    .song-accuracy {
        font-family: 'Orbitron', monospace;
        font-weight: 900;
        font-size: 1.2rem;
    }

    .accuracy-good { color: var(--success); }
    .accuracy-medium { color: var(--warning); }
    .accuracy-bad { color: var(--danger); }

    .song-actions {
        display: flex;
        gap: 5px;
    }

    .icon-btn {
        padding: 8px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.3);
        color: var(--electric);
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.85rem;
    }

    .icon-btn:hover {
        background: rgba(0, 240, 255, 0.2);
        border-color: var(--electric);
    }

    .training-panel {
        grid-column: span 4;
        background: rgba(17, 24, 39, 0.8);
        border: 2px solid var(--warning);
        border-radius: 16px;
        padding: 25px;
    }

    .progress-bar {
        width: 100%;
        height: 30px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        overflow: hidden;
        position: relative;
        margin: 20px 0;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--electric), var(--success));
        transition: width 0.5s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        color: var(--void);
    }

    .training-log {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 15px;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.8rem;
        margin-top: 15px;
    }

    .log-entry {
        padding: 5px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-success { color: var(--success); }
    .log-error { color: var(--danger); }
    .log-info { color: var(--info); }

    .metrics-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-top: 20px;
    }

    .metric-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 20px;
        text-align: center;
    }

    .metric-value {
        font-family: 'Orbitron', monospace;
        font-size: 2.5rem;
        font-weight: 900;
        color: var(--electric);
        margin: 10px 0;
    }

    .metric-label {
        font-size: 0.7rem;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    input[type="text"], input[type="number"], select, textarea {
        width: 100%;
        padding: 12px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--text);
        font-family: 'JetBrains Mono', monospace;
        margin: 8px 0;
    }

    input:focus, select:focus, textarea:focus {
        outline: none;
        border-color: var(--electric);
        box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
    }

    textarea {
        min-height: 150px;
        font-size: 0.85rem;
        resize: vertical;
    }

    input[type="file"] {
        width: 100%;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--text);
        cursor: pointer;
    }

    .btn-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }

    button {
        flex: 1;
        padding: 14px;
        border: none;
        border-radius: 8px;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--electric), #0066ff);
        color: var(--void);
        box-shadow: 0 4px 15px rgba(0, 240, 255, 0.3);
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 240, 255, 0.5);
    }

    .btn-success {
        background: linear-gradient(135deg, var(--success), #059669);
        color: var(--void);
    }

    .btn-warning {
        background: linear-gradient(135deg, var(--warning), #d97706);
        color: var(--void);
    }

    .btn-danger {
        background: linear-gradient(135deg, var(--neon), #cc0055);
        color: white;
    }

    .hidden {
        display: none !important;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal.show {
        display: flex;
    }

    .modal-content {
        background: var(--card);
        border: 2px solid var(--electric);
        border-radius: 16px;
        padding: 30px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
    }

    .modal-title {
        font-family: 'Orbitron', monospace;
        font-size: 1.5rem;
        font-weight: 900;
        color: var(--electric);
        margin-bottom: 20px;
    }

    .close-modal {
        float: right;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--danger);
    }

    audio {
        width: 100%;
        margin-top: 10px;
        border-radius: 8px;
        filter: invert(1) hue-rotate(180deg);
    }

    canvas {
        width: 100%;
        height: 140px;
        background: var(--void);
        border-radius: 12px;
        border: 1px solid rgba(0, 240, 255, 0.2);
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        font-size: 0.7rem;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #64748b;
        animation: pulse 2s infinite;
    }

    .status-dot.active {
        background: var(--success);
        box-shadow: 0 0 10px var(--success);
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .timeline-container {
        grid-column: span 4;
        background: rgba(10, 14, 39, 0.8);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        margin-top: 20px;
    }

    #chord-timeline {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        padding: 15px;
        min-height: 80px;
        scrollbar-width: thin;
        scrollbar-color: var(--electric) var(--void);
        align-items: flex-end;
    }

    .chord-event {
        min-width: 100px;
        padding: 12px 16px;
        background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(255, 0, 110, 0.1));
        border: 1px solid var(--electric);
        border-left: 3px solid var(--neon);
        border-radius: 8px;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.9rem;
        color: var(--gold);
        text-align: center;
        animation: eventSlide 0.4s;
        cursor: pointer;
        transition: all 0.3s;
        position: relative;
    }

    .chord-event.correct {
        border-color: var(--success);
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
    }

    .chord-event.wrong {
        border-color: var(--danger);
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
    }

    @keyframes eventSlide {
        from { opacity: 0; transform: translateX(30px) scale(0.8); }
        to { opacity: 1; transform: translateX(0) scale(1); }
    }
</style>
</head>
<body>

<div class="container">
    <h1>
        üß† TRI LEARNING ENGINE
        <span class="version">v6.0 OPERATIONAL ‚Ä¢ Full Bass-Focused Detection</span>
    </h1>

    <!-- MODE SELECTOR -->
    <div class="mode-selector">
        <button class="mode-btn active" onclick="switchMode('database')" id="mode-db">
            üìÇ DATABASE
        </button>
        <button class="mode-btn" onclick="switchMode('training')" id="mode-train">
            ü§ñ TRAINING
        </button>
        <button class="mode-btn" onclick="switchMode('performance')" id="mode-perf">
            üé∏ PERFORMANCE
        </button>
    </div>

    <!-- DATABASE MODE -->
    <div id="database-mode">
        <div class="db-panel">
            <div class="tri-title">
                <span>üìö MY REPERTOIRE</span>
                <div style="display: flex; gap: 10px;">
                    <button class="btn-warning" style="flex: none; padding: 8px 16px; font-size: 0.7rem;" onclick="DB.exportDatabase()">
                        üì• EXPORT
                    </button>
                    <button class="btn-primary" style="flex: none; padding: 8px 16px;" onclick="openAddSongModal()">
                        ‚ûï ADD SONG
                    </button>
                </div>
            </div>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Total Songs</div>
                    <div class="metric-value" id="total-songs">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Trained Songs</div>
                    <div class="metric-value" id="trained-songs" style="color: var(--success);">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Avg Accuracy</div>
                    <div class="metric-value" id="avg-accuracy">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Chords</div>
                    <div class="metric-value" id="total-chords">0</div>
                </div>
            </div>

            <div class="song-list" id="song-list"></div>
        </div>
    </div>

    <!-- TRAINING MODE -->
    <div id="training-mode" class="hidden">
        <div class="training-panel">
            <div class="tri-title">
                <span>ü§ñ AUTO-TRAINING ENGINE</span>
            </div>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Current Accuracy</div>
                    <div class="metric-value" id="current-accuracy">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Correct Chords</div>
                    <div class="metric-value" id="train-correct" style="color: var(--success);">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Wrong Chords</div>
                    <div class="metric-value" id="train-wrong" style="color: var(--danger);">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Songs Analyzed</div>
                    <div class="metric-value" id="train-songs">0</div>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="train-progress" style="width: 0%;">0%</div>
            </div>

            <div class="btn-group">
                <button class="btn-success" onclick="startTraining()">
                    üöÄ START TRAINING
                </button>
                <button class="btn-warning" onclick="stopTraining()">
                    ‚è∏Ô∏è STOP
                </button>
                <button class="btn-danger" onclick="resetTraining()">
                    üîÑ RESET
                </button>
            </div>

            <div class="training-log" id="training-log">
                <div class="log-entry log-info">[System] Training log ready...</div>
            </div>
        </div>
    </div>

    <!-- PERFORMANCE MODE -->
    <div id="performance-mode" class="hidden">
        <div class="tri-grid">
            <div class="tri-block" style="grid-column: span 4;">
                <div class="tri-title">
                    <span>üéµ AUDIO SOURCE</span>
                </div>
                <input type="file" id="audio-input-perf" accept="audio/*">
                <audio id="audio-player" controls crossorigin="anonymous"></audio>
            </div>

            <div class="tri-block">
                <div class="tri-title">
                    <span>üé∏ BASS DETECTION</span>
                </div>
                <div id="bass-freq" class="tri-value" style="font-size: 1.8rem; color: var(--success);">--</div>
                <div class="info-label">
                    Bass Note: <span id="bass-note" class="info-data">--</span>
                </div>
            </div>

            <div class="tri-block">
                <div class="tri-title">
                    <span>üéº DETECTED CHORD</span>
                </div>
                <div id="chord-display" class="tri-value">--</div>
                <div class="info-label">
                    Confidence: <span id="confidence-display" class="info-data">0%</span>
                </div>
            </div>

            <div class="tri-block">
                <div class="tri-title">
                    <span>üîë KEY</span>
                </div>
                <div id="key-display" class="tri-value" style="font-size: 1.5rem; color: var(--success);">--</div>
            </div>

            <div class="tri-block">
                <div class="tri-title">
                    <span>‚öôÔ∏è OPTIMIZED CONFIG</span>
                </div>
                <div style="font-size: 0.85rem; line-height: 1.8;">
                    Bass Range: <span id="config-bass" class="info-data">250 Hz</span><br>
                    Tonal Weight: <span id="config-tonal" class="info-data">0.9</span><br>
                    Min Confidence: <span id="config-conf" class="info-data">35%</span><br>
                    Stability: <span id="config-stab" class="info-data">6 frames</span>
                </div>
            </div>

            <div class="tri-block" style="grid-column: span 2;">
                <div class="tri-title">
                    <span>üìä SPECTRUM</span>
                </div>
                <canvas id="spectrum-canvas"></canvas>
            </div>

            <div class="tri-block">
                <div class="tri-title">
                    <span>üìà METRICS</span>
                </div>
                <div style="font-size: 0.85rem; line-height: 1.8;">
                    Stability: <span id="stability-display" class="info-data">0%</span><br>
                    Frame: <span id="frame-display" class="info-data">0</span><br>
                    Time: <span id="time-display" class="info-data">0.00s</span>
                </div>
            </div>

            <div class="tri-block" style="grid-column: span 4;">
                <div class="tri-title">
                    <span>üéõÔ∏è ENGINE CONTROL</span>
                </div>
                <div class="btn-group">
                    <button class="btn-primary" onclick="startPerformance()">
                        üöÄ START ANALYSIS
                    </button>
                    <button class="btn-danger" onclick="stopPerformance()">
                        ‚èπÔ∏è STOP
                    </button>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Ready ‚Ä¢ Bass-Focused Mode</span>
                </div>
            </div>
        </div>

        <div class="timeline-container">
            <div class="tri-title">
                <span>üìù CHORD TIMELINE</span>
            </div>
            <div id="chord-timeline"></div>
        </div>
    </div>
</div>

<!-- ADD SONG MODAL -->
<div class="modal" id="add-song-modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeAddSongModal()">√ó</span>
        <div class="modal-title">‚ûï Add New Song</div>

        <label class="info-label">Song Title *</label>
        <input type="text" id="song-title" placeholder="e.g., Talkin' Bout a Revolution">

        <label class="info-label">Artist *</label>
        <input type="text" id="song-artist" placeholder="e.g., Tracy Chapman">

        <label class="info-label">Key / Tonalit√© *</label>
        <select id="song-key">
            <option value="C Major">C Major</option>
            <option value="G Major">G Major</option>
            <option value="D Major">D Major</option>
            <option value="A Major">A Major</option>
            <option value="E Major">E Major</option>
            <option value="F Major">F Major</option>
            <option value="A minor">A minor</option>
            <option value="E minor">E minor</option>
            <option value="D minor">D minor</option>
        </select>

        <label class="info-label">BPM</label>
        <input type="number" id="song-bpm" placeholder="120" value="120">

        <label class="info-label">Audio File (for training) *</label>
        <input type="file" id="song-audio" accept="audio/*">

        <label class="info-label">Chord Structure (JSON format) *</label>
        <textarea id="song-structure" placeholder='[
  {"start": 0, "end": 3.5, "chord": "G Major"},
  {"start": 3.5, "end": 7, "chord": "C Major"},
  {"start": 7, "end": 10.5, "chord": "E minor"},
  {"start": 10.5, "end": 14, "chord": "D Major"}
]'></textarea>

        <div class="btn-group">
            <button class="btn-success" onclick="saveSong()">üíæ SAVE SONG</button>
            <button class="btn-danger" onclick="closeAddSongModal()">‚ùå CANCEL</button>
        </div>
    </div>
</div>

<script src="TRI_v6.0_OPERATIONAL.js"></script>

<script>
// Embedded operational code
/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * TRI v6.0 OPERATIONAL - COMPLETE SYSTEM
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

// CONFIG
const CONFIG = {
    notes: ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
    
    chordIntervals: {
        'Major':     [0, 4, 7],
        'minor':     [0, 3, 7],
        '7':         [0, 4, 7, 10],
        'maj7':      [0, 4, 7, 11],
        'm7':        [0, 3, 7, 10],
        'sus4':      [0, 5, 7],
        'sus2':      [0, 2, 7],
        'dim':       [0, 3, 6],
        'aug':       [0, 4, 8],
    },
    
    scales: {
        major: [0, 2, 4, 5, 7, 9, 11],
        minor: [0, 2, 3, 5, 7, 8, 10],
    },
    
    fftSize: 16384,
    smoothing: 0.75,
    bassMinFreq: 40,
    bassMaxFreq: 250,
    harmonicsMaxFreq: 2000,
    stabilityThreshold: 6,
    harmonicTolerance: 0.015,
    minConfidence: 35,
    referenceA: 440,
};

// DATABASE
const DB = {
    songs: [],
    config: { ...CONFIG },
    
    save() {
        localStorage.setItem('tri_songs', JSON.stringify(this.songs));
        localStorage.setItem('tri_config', JSON.stringify(this.config));
    },
    
    load() {
        const songs = localStorage.getItem('tri_songs');
        const config = localStorage.getItem('tri_config');
        if (songs) this.songs = JSON.parse(songs);
        if (config) this.config = JSON.parse(config);
    },
    
    addSong(song) {
        song.id = Date.now().toString();
        song.dateAdded = new Date().toISOString();
        song.accuracy = null;
        song.trained = false;
        song.errors = [];
        this.songs.push(song);
        this.save();
        return song;
    },
    
    getSong(id) {
        return this.songs.find(s => s.id === id);
    },
    
    deleteSong(id) {
        this.songs = this.songs.filter(s => s.id !== id);
        this.save();
    },
    
    updateSongResults(id, accuracy, errors) {
        const song = this.getSong(id);
        if (song) {
            song.accuracy = accuracy;
            song.trained = true;
            song.errors = errors;
            song.lastTrained = new Date().toISOString();
            this.save();
        }
    },
    
    exportDatabase() {
        const data = {
            songs: this.songs,
            config: this.config,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `TRI_Database_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        log('üì• Database exported', 'success');
    }
};

DB.load();

// STATE
const state = {
    audioCtx: null,
    analyser: null,
    source: null,
    isRunning: false,
    
    frameCount: 0,
    lastChord: null,
    stability: 0,
    
    chordHistory: [],
    
    currentBassFreq: null,
    currentBassNote: null,
    
    keyHistory: new Array(12).fill(0),
    detectedKey: null,
    detectedScale: null,
};

// UI
const UI = {
    player: document.getElementById('audio-player'),
    spectrumCanvas: document.getElementById('spectrum-canvas'),
    timeline: document.getElementById('chord-timeline'),
    
    chordDisplay: document.getElementById('chord-display'),
    keyDisplay: document.getElementById('key-display'),
    
    bassFreqDisplay: document.getElementById('bass-freq'),
    bassNoteDisplay: document.getElementById('bass-note'),
    
    confidenceDisplay: document.getElementById('confidence-display'),
    
    timeDisplay: document.getElementById('time-display'),
    stabilityDisplay: document.getElementById('stability-display'),
    frameDisplay: document.getElementById('frame-display'),
    
    statusDot: document.getElementById('status-dot'),
    statusText: document.getElementById('status-text'),
};

// MODE SWITCHING
function switchMode(mode) {
    document.getElementById('database-mode').classList.add('hidden');
    document.getElementById('training-mode').classList.add('hidden');
    document.getElementById('performance-mode').classList.add('hidden');
    
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    
    if (mode === 'database') {
        document.getElementById('database-mode').classList.remove('hidden');
        document.getElementById('mode-db').classList.add('active');
        refreshSongList();
    } else if (mode === 'training') {
        document.getElementById('training-mode').classList.remove('hidden');
        document.getElementById('mode-train').classList.add('active');
    } else if (mode === 'performance') {
        document.getElementById('performance-mode').classList.remove('hidden');
        document.getElementById('mode-perf').classList.add('active');
        loadOptimizedConfig();
    }
}

// DATABASE FUNCTIONS
function refreshSongList() {
    const container = document.getElementById('song-list');
    
    if (DB.songs.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #64748b;">
                üìÇ No songs yet. Click "ADD SONG" to start building your repertoire!
            </div>
        `;
        updateDatabaseStats();
        return;
    }
    
    container.innerHTML = '';
    
    DB.songs.forEach(song => {
        const item = document.createElement('div');
        item.className = 'song-item';
        
        const accuracyClass = song.accuracy >= 80 ? 'accuracy-good' : 
                             song.accuracy >= 50 ? 'accuracy-medium' : 'accuracy-bad';
        
        item.innerHTML = `
            <div>
                <div class="song-title">${song.title}</div>
                <div class="song-artist">${song.artist}</div>
            </div>
            <div class="song-key">${song.key}</div>
            <div>
                <div style="font-size: 0.8rem; color: #94a3b8;">Chords</div>
                <div style="font-weight: 700;">${song.structure.length}</div>
            </div>
            <div>
                ${song.trained ? 
                    `<div class="song-accuracy ${accuracyClass}">${song.accuracy.toFixed(1)}%</div>` :
                    `<div style="color: #64748b; font-size: 0.9rem;">Not trained</div>`
                }
            </div>
            <div class="song-actions">
                <button class="icon-btn" onclick="deleteSong('${song.id}')" title="Delete">
                    üóëÔ∏è
                </button>
            </div>
        `;
        
        container.appendChild(item);
    });
    
    updateDatabaseStats();
}

function updateDatabaseStats() {
    document.getElementById('total-songs').textContent = DB.songs.length;
    
    const trained = DB.songs.filter(s => s.trained).length;
    document.getElementById('trained-songs').textContent = trained;
    
    const avgAcc = trained > 0 ? 
        DB.songs.filter(s => s.trained).reduce((sum, s) => sum + s.accuracy, 0) / trained : 0;
    document.getElementById('avg-accuracy').textContent = avgAcc.toFixed(1) + '%';
    
    const totalChords = DB.songs.reduce((sum, s) => sum + s.structure.length, 0);
    document.getElementById('total-chords').textContent = totalChords;
}

function openAddSongModal() {
    document.getElementById('add-song-modal').classList.add('show');
}

function closeAddSongModal() {
    document.getElementById('add-song-modal').classList.remove('show');
}

function saveSong() {
    const title = document.getElementById('song-title').value.trim();
    const artist = document.getElementById('song-artist').value.trim();
    const key = document.getElementById('song-key').value;
    const bpm = parseInt(document.getElementById('song-bpm').value) || 120;
    const audioFile = document.getElementById('song-audio').files[0];
    const structureText = document.getElementById('song-structure').value.trim();
    
    // Validation
    if (!title) {
        alert('‚ùå Please enter a song title!');
        return;
    }
    
    if (!artist) {
        alert('‚ùå Please enter an artist name!');
        return;
    }
    
    if (!structureText) {
        alert('‚ùå Please enter the chord structure (JSON format)!');
        return;
    }
    
    // Parse JSON structure
    let structure = [];
    try {
        structure = JSON.parse(structureText);
        
        // Validate structure format
        if (!Array.isArray(structure) || structure.length === 0) {
            alert('‚ùå Chord structure must be a non-empty array!');
            return;
        }
        
        // Check each segment has required fields
        for (let i = 0; i < structure.length; i++) {
            const seg = structure[i];
            if (typeof seg.start === 'undefined' || typeof seg.end === 'undefined' || !seg.chord) {
                alert(`‚ùå Segment ${i + 1} is missing required fields (start, end, chord)!`);
                return;
            }
        }
        
    } catch (e) {
        alert('‚ùå Invalid JSON format!\n\nError: ' + e.message + '\n\nExample format:\n[\n  {"start": 0, "end": 2, "chord": "G Major"},\n  {"start": 2, "end": 4, "chord": "C Major"}\n]');
        return;
    }
    
    // Audio file is OPTIONAL for training
    // If no audio, song can still be added but won't be trainable
    if (!audioFile) {
        if (!confirm('‚ö†Ô∏è No audio file selected.\n\nThe song will be added but cannot be trained without audio.\n\nContinue anyway?')) {
            return;
        }
        
        // Save without audio
        const song = {
            title,
            artist,
            key,
            bpm,
            structure,
            audioBlob: null
        };
        
        DB.addSong(song);
        closeAddSongModal();
        refreshSongList();
        log('‚úÖ Song added (no audio): ' + title, 'success');
        alert('‚úÖ Song added successfully!\n\n‚ö†Ô∏è Add an audio file later to enable training.');
        return;
    }
    
    // Save with audio
    const reader = new FileReader();
    reader.onload = (e) => {
        const song = {
            title,
            artist,
            key,
            bpm,
            structure,
            audioBlob: e.target.result
        };
        
        DB.addSong(song);
        closeAddSongModal();
        refreshSongList();
        log('‚úÖ Song added with audio: ' + title, 'success');
        alert('‚úÖ Song "' + title + '" added successfully!\n\nüéµ ' + structure.length + ' chords defined\nüé∏ Ready for training');
    };
    
    reader.onerror = () => {
        alert('‚ùå Error reading audio file!');
    };
    
    reader.readAsDataURL(audioFile);
}

function deleteSong(id) {
    if (confirm('Delete this song?')) {
        const song = DB.getSong(id);
        DB.deleteSong(id);
        refreshSongList();
        log('üóëÔ∏è Deleted: ' + song.title, 'info');
    }
}

// TRAINING
let trainingState = {
    isRunning: false,
    currentSongIndex: 0,
    totalCorrect: 0,
    totalWrong: 0,
    analyzedSongs: 0,
};

async function startTraining() {
    if (DB.songs.length === 0) {
        alert('No songs in database!');
        return;
    }
    
    trainingState = {
        isRunning: true,
        currentSongIndex: 0,
        totalCorrect: 0,
        totalWrong: 0,
        analyzedSongs: 0,
    };
    
    log('üöÄ Starting training on ' + DB.songs.length + ' songs...', 'info');
    
    await processNextSong();
}

async function processNextSong() {
    if (!trainingState.isRunning || trainingState.currentSongIndex >= DB.songs.length) {
        completeTraining();
        return;
    }
    
    const song = DB.songs[trainingState.currentSongIndex];
    log(`üìù Training: ${song.title}...`, 'info');
    
    // CRITICAL: Initialize audio context BEFORE loading audio
    if (!state.audioCtx) {
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    if (state.audioCtx.state === 'suspended') {
        await state.audioCtx.resume();
    }
    
    // Load audio
    UI.player.src = song.audioBlob;
    
    // Wait for audio to be ready
    await new Promise((resolve, reject) => {
        UI.player.onloadeddata = resolve;
        UI.player.onerror = () => reject(new Error('Audio load failed'));
        setTimeout(() => reject(new Error('Audio load timeout')), 5000);
    });
    
    // Create analyser if needed
    if (!state.analyser) {
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = CONFIG.fftSize;
        state.analyser.smoothingTimeConstant = 0.5;
    }
    
    // CRITICAL: Connect audio source
    if (!state.source || state.source.mediaElement !== UI.player) {
        // Disconnect old source if exists
        if (state.source) {
            try {
                state.source.disconnect();
            } catch (e) {}
        }
        
        // Create new source
        state.source = state.audioCtx.createMediaElementSource(UI.player);
        state.source.connect(state.analyser);
        state.analyser.connect(state.audioCtx.destination);
        
        log('  üîä Audio context connected', 'info');
    }
    
    // Analyze each segment with IMPROVED detection
    let songCorrect = 0;
    let songWrong = 0;
    let errors = [];
    
    for (let i = 0; i < song.structure.length; i++) {
        const segment = song.structure[i];
        
        log(`  üîç Analyzing segment ${i + 1}/${song.structure.length} [${segment.start}s]...`, 'info');
        
        const detected = await detectChordForSegment(segment);
        
        if (detected && detected.chord === segment.chord) {
            songCorrect++;
            trainingState.totalCorrect++;
            log(`  ‚úÖ [${segment.start}s] ${segment.chord} ‚Üí Correct (${detected.confidence.toFixed(0)}%)`, 'success');
        } else {
            songWrong++;
            trainingState.totalWrong++;
            errors.push({
                timestamp: segment.start,
                expected: segment.chord,
                detected: detected ? detected.chord : 'None'
            });
            log(`  ‚ùå [${segment.start}s] Expected ${segment.chord}, got ${detected ? detected.chord : 'None'}`, 'error');
        }
        
        // Small delay between segments
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    const songAccuracy = (songCorrect / (songCorrect + songWrong)) * 100;
    DB.updateSongResults(song.id, songAccuracy, errors);
    
    trainingState.analyzedSongs++;
    trainingState.currentSongIndex++;
    
    // Update UI
    const overall = (trainingState.totalCorrect / (trainingState.totalCorrect + trainingState.totalWrong)) * 100;
    document.getElementById('current-accuracy').textContent = overall.toFixed(1) + '%';
    document.getElementById('train-correct').textContent = trainingState.totalCorrect;
    document.getElementById('train-wrong').textContent = trainingState.totalWrong;
    document.getElementById('train-songs').textContent = trainingState.analyzedSongs;
    
    const progress = (trainingState.analyzedSongs / DB.songs.length) * 100;
    document.getElementById('train-progress').style.width = progress + '%';
    document.getElementById('train-progress').textContent = progress.toFixed(0) + '%';
    
    // Continue
    setTimeout(() => processNextSong(), 100);
}

/**
 * AM√âLIORATION CRITIQUE: D√©tection sur segment entier
 * Au lieu d'analyser 1 frame, on analyse toute la dur√©e
 */
async function detectChordForSegment(segment) {
    const duration = Math.min(segment.end - segment.start, 2.0); // Max 2 secondes
    const numSamples = 8; // 8 √©chantillons sur la dur√©e
    const sampleInterval = duration / numSamples;
    
    // Accumulateurs pour moyenner sur le segment
    const bassVotes = new Array(12).fill(0);
    const harmonicProfiles = new Array(12).fill(0);
    
    // CRITICAL: Seek to start position
    UI.player.currentTime = segment.start + 0.3; // √âvite l'attaque, d√©calage pour stabilit√©
    
    // Wait for seek to complete
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // CRITICAL: Start playback
    try {
        await UI.player.play();
    } catch (e) {
        log(`    ‚ö†Ô∏è Play error: ${e.message}`, 'error');
        return null;
    }
    
    // √âchantillonne plusieurs fois pendant le segment
    for (let i = 0; i < numSamples; i++) {
        await new Promise(resolve => setTimeout(resolve, sampleInterval * 1000));
        
        const bufferLength = state.analyser.frequencyBinCount;
        const spectrum = new Uint8Array(bufferLength);
        state.analyser.getByteFrequencyData(spectrum);
        
        // V√©rifie qu'on a du signal
        const maxSignal = Math.max(...spectrum);
        if (maxSignal < 50) {
            log(`    ‚ö†Ô∏è Low signal at sample ${i + 1}: ${maxSignal}`, 'info');
            continue;
        }
        
        // D√©tecte basse √† cet instant
        const bass = detectBassNote(spectrum);
        if (bass && bass.power > 15) { // Seuil plus permissif
            bassVotes[bass.note]++;
        }
        
        // Accumule harmoniques
        const harmonics = analyzeHarmonics(spectrum, bass ? bass.note : 0);
        for (let j = 0; j < 12; j++) {
            harmonicProfiles[j] += harmonics[j];
        }
    }
    
    // CRITICAL: Stop playback
    UI.player.pause();
    
    // Vote majoritaire pour la basse
    const maxVotes = Math.max(...bassVotes);
    const dominantBassNote = bassVotes.indexOf(maxVotes);
    const bassConfidence = maxVotes / numSamples;
    
    if (bassConfidence < 0.25) {
        // Pas assez de d√©tections coh√©rentes
        log(`    ‚ö†Ô∏è Low bass confidence: ${(bassConfidence * 100).toFixed(0)}%`, 'info');
        return null;
    }
    
    // Normalise le profil harmonique moyen
    const maxHarmonic = Math.max(...harmonicProfiles);
    if (maxHarmonic > 0) {
        for (let i = 0; i < 12; i++) {
            harmonicProfiles[i] /= maxHarmonic;
        }
    }
    
    // D√©termine le type d'accord
    const chordType = determineChordType(dominantBassNote, harmonicProfiles);
    
    const finalConfidence = (bassConfidence * 50 + chordType.score * 50);
    
    log(`    üìä Bass: ${CONFIG.notes[dominantBassNote]} (${(bassConfidence * 100).toFixed(0)}%), Type: ${chordType.type} (${(chordType.score * 100).toFixed(0)}%)`, 'info');
    
    return {
        chord: CONFIG.notes[dominantBassNote] + ' ' + chordType.type,
        confidence: finalConfidence
    };
}

function detectBassNote(spectrum) {
    const sampleRate = state.audioCtx.sampleRate;
    const binWidth = sampleRate / CONFIG.fftSize;
    
    let maxMagnitude = 0;
    let bassBin = -1;
    
    for (let i = 0; i < spectrum.length; i++) {
        const freq = i * binWidth;
        
        if (freq < CONFIG.bassMinFreq) continue;
        if (freq > CONFIG.bassMaxFreq) break;
        
        if (spectrum[i] > maxMagnitude) {
            maxMagnitude = spectrum[i];
            bassBin = i;
        }
    }
    
    if (bassBin === -1 || maxMagnitude < 80) return null;
    
    const bassFreq = bassBin * binWidth;
    const bassNote = freqToNoteIndex(bassFreq);
    
    const totalEnergy = spectrum.reduce((a, b) => a + b, 0);
    const bassPower = (maxMagnitude / (totalEnergy / spectrum.length)) * 100;
    
    return {
        freq: bassFreq,
        note: bassNote,
        noteName: CONFIG.notes[bassNote],
        magnitude: maxMagnitude,
        power: bassPower
    };
}

function analyzeHarmonics(spectrum, bassNote) {
    const sampleRate = state.audioCtx.sampleRate;
    const binWidth = sampleRate / CONFIG.fftSize;
    
    const pitchProfile = new Array(12).fill(0);
    
    for (let i = 0; i < spectrum.length; i++) {
        const freq = i * binWidth;
        
        if (freq <= CONFIG.bassMaxFreq) continue;
        if (freq > CONFIG.harmonicsMaxFreq) break;
        
        if (spectrum[i] > 100) {
            const noteIndex = freqToNoteIndex(freq);
            if (noteIndex !== -1) {
                pitchProfile[noteIndex] += spectrum[i];
            }
        }
    }
    
    const maxPitch = Math.max(...pitchProfile);
    if (maxPitch > 0) {
        for (let i = 0; i < 12; i++) {
            pitchProfile[i] /= maxPitch;
        }
    }
    
    return pitchProfile;
}

function determineChordType(bassNote, pitchProfile) {
    let bestMatch = { type: 'Major', score: 0 };
    
    for (let chordType in CONFIG.chordIntervals) {
        const intervals = CONFIG.chordIntervals[chordType];
        let score = 0;
        
        intervals.forEach(interval => {
            const expectedNote = (bassNote + interval) % 12;
            score += pitchProfile[expectedNote];
        });
        
        score /= intervals.length;
        
        if (score > bestMatch.score) {
            bestMatch = { type: chordType, score: score };
        }
    }
    
    return bestMatch;
}

function freqToNoteIndex(freq) {
    if (freq < CONFIG.bassMinFreq) return -1;
    
    const midi = 12 * Math.log2(freq / CONFIG.referenceA) + 69;
    const noteIndex = Math.round(midi) % 12;
    
    return (noteIndex + 12) % 12;
}

function completeTraining() {
    trainingState.isRunning = false;
    
    const accuracy = (trainingState.totalCorrect / (trainingState.totalCorrect + trainingState.totalWrong)) * 100;
    
    log(`üéâ Training complete! Overall: ${accuracy.toFixed(1)}%`, 'success');
    
    refreshSongList();
}

function stopTraining() {
    trainingState.isRunning = false;
    log('‚è∏Ô∏è Training stopped', 'info');
}

function resetTraining() {
    stopTraining();
    
    DB.songs.forEach(song => {
        song.accuracy = null;
        song.trained = false;
        song.errors = [];
    });
    
    DB.save();
    
    document.getElementById('current-accuracy').textContent = '0%';
    document.getElementById('train-correct').textContent = '0';
    document.getElementById('train-wrong').textContent = '0';
    document.getElementById('train-songs').textContent = '0';
    document.getElementById('train-progress').style.width = '0%';
    
    clearLog();
    refreshSongList();
}

// PERFORMANCE MODE
function loadOptimizedConfig() {
    document.getElementById('config-bass').textContent = DB.config.bassMaxFreq + ' Hz';
    document.getElementById('config-tonal').textContent = '0.9';
    document.getElementById('config-conf').textContent = DB.config.minConfidence + '%';
    document.getElementById('config-stab').textContent = DB.config.stabilityThreshold + ' frames';
}

async function startPerformance() {
    if (!state.audioCtx) {
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = CONFIG.fftSize;
        state.analyser.smoothingTimeConstant = CONFIG.smoothing;
        
        state.source = state.audioCtx.createMediaElementSource(UI.player);
        state.source.connect(state.analyser);
        state.analyser.connect(state.audioCtx.destination);
    }
    
    if (state.audioCtx.state === 'suspended') {
        await state.audioCtx.resume();
    }
    
    state.isRunning = true;
    UI.player.play();
    
    UI.statusDot.classList.add('active');
    UI.statusText.textContent = 'Analysis running...';
    
    performanceLoop();
}

function stopPerformance() {
    state.isRunning = false;
    UI.player.pause();
    
    UI.statusDot.classList.remove('active');
    UI.statusText.textContent = 'Stopped';
}

function performanceLoop() {
    if (!state.isRunning) return;
    
    state.frameCount++;
    UI.frameDisplay.textContent = state.frameCount;
    UI.timeDisplay.textContent = UI.player.currentTime.toFixed(2) + 's';
    
    const bufferLength = state.analyser.frequencyBinCount;
    const spectrum = new Uint8Array(bufferLength);
    state.analyser.getByteFrequencyData(spectrum);
    
    const bass = detectBassNote(spectrum);
    
    if (bass && bass.power > 20) {
        UI.bassFreqDisplay.textContent = bass.freq.toFixed(1) + ' Hz';
        UI.bassNoteDisplay.textContent = bass.noteName;
        
        const pitchProfile = analyzeHarmonics(spectrum, bass.note);
        const chordType = determineChordType(bass.note, pitchProfile);
        
        const chordName = bass.noteName + ' ' + chordType.type;
        const confidence = chordType.score * 100;
        
        if (chordName === state.lastChord && confidence >= CONFIG.minConfidence) {
            state.stability++;
        } else {
            state.stability = 0;
            state.lastChord = chordName;
        }
        
        const stabilityPercent = Math.min(100, (state.stability / CONFIG.stabilityThreshold) * 100);
        UI.stabilityDisplay.textContent = stabilityPercent.toFixed(0) + '%';
        
        if (state.stability >= CONFIG.stabilityThreshold) {
            UI.chordDisplay.textContent = chordName;
            UI.confidenceDisplay.textContent = confidence.toFixed(1) + '%';
            
            addToTimeline(chordName, UI.player.currentTime, confidence);
        }
    }
    
    drawSpectrum(spectrum);
    
    requestAnimationFrame(performanceLoop);
}

function addToTimeline(chord, timestamp, confidence) {
    if (state.chordHistory.length > 0) {
        const lastEntry = state.chordHistory[state.chordHistory.length - 1];
        if (lastEntry.chord === chord) return;
        if (timestamp - lastEntry.timestamp < 0.8) return;
    }
    
    state.chordHistory.push({ chord, timestamp, confidence });
    
    const event = document.createElement('div');
    event.className = 'chord-event';
    event.innerHTML = `
        ${chord}
        <div style="font-size: 0.6rem; color: #64748b; margin-top: 4px;">
            ${timestamp.toFixed(1)}s
        </div>
    `;
    
    UI.timeline.appendChild(event);
    UI.timeline.scrollLeft = UI.timeline.scrollWidth;
}

function drawSpectrum(spectrum) {
    const canvas = UI.spectrumCanvas;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const barCount = 120;
    const barWidth = width / barCount;
    
    for (let i = 0; i < barCount; i++) {
        const value = spectrum[i] / 255;
        const barHeight = value * height;
        
        const hue = 180 + (i / barCount) * 60;
        ctx.fillStyle = `hsl(${hue}, 80%, ${50 + value * 30}%)`;
        
        ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
    }
}

// LOGGING
function log(message, type = 'info') {
    const logContainer = document.getElementById('training-log');
    if (!logContainer) return;
    
    const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logContainer.appendChild(entry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

function clearLog() {
    const logContainer = document.getElementById('training-log');
    if (logContainer) {
        logContainer.innerHTML = '<div class="log-entry log-info">[System] Log cleared</div>';
    }
}

// INITIALIZATION
window.addEventListener('DOMContentLoaded', () => {
    refreshSongList();
    
    // Audio input for performance mode
    document.getElementById('audio-input-perf').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            UI.player.src = URL.createObjectURL(file);
        }
    });
    
    console.log('%cüß† TRI LEARNING ENGINE v6.0 OPERATIONAL', 'color: #00f0ff; font-size: 18px; font-weight: bold;');
    console.log('%c‚úÖ All systems online', 'color: #00ff88;');
});

</script>
</body>
</html>
