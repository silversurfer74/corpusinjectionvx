<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TRI ULTIMATE v5.4 ‚Ä¢ Advanced Chord Recognition System</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;600&display=swap');
    
    :root {
        --void: #000000;
        --deep: #0a0e27;
        --card: #111827;
        --electric: #00f0ff;
        --neon: #ff006e;
        --gold: #ffd60a;
        --success: #00ff88;
        --danger: #ef4444;
        --warning: #fbbf24;
        --border: #1e293b;
        --text: #e0e7ff;
        --glow: rgba(0, 240, 255, 0.4);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
        background: radial-gradient(ellipse at top, var(--deep), var(--void));
        color: var(--text);
        font-family: 'JetBrains Mono', monospace;
        min-height: 100vh;
        padding: 20px;
        position: relative;
        overflow-x: hidden;
    }

    body::before {
        content: '';
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: 
            repeating-linear-gradient(0deg, rgba(0,240,255,0.03) 0px, transparent 1px, transparent 2px, rgba(0,240,255,0.03) 3px),
            repeating-linear-gradient(90deg, rgba(0,240,255,0.03) 0px, transparent 1px, transparent 2px, rgba(0,240,255,0.03) 3px);
        pointer-events: none;
        z-index: 0;
    }

    .container {
        max-width: 1800px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
    }

    h1 {
        font-family: 'Orbitron', monospace;
        font-size: 2.5rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 40px;
        background: linear-gradient(135deg, var(--electric), var(--neon), var(--gold));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-transform: uppercase;
        letter-spacing: 4px;
        animation: titlePulse 4s ease-in-out infinite;
    }

    @keyframes titlePulse {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.3); }
    }

    .version {
        display: block;
        font-size: 0.7rem;
        color: var(--electric);
        margin-top: 8px;
        letter-spacing: 2px;
    }

    .tri-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-bottom: 20px;
    }

    .tri-block {
        background: rgba(17, 24, 39, 0.6);
        backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        position: relative;
        transition: all 0.3s;
        overflow: hidden;
    }

    .tri-block::before {
        content: '';
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 2px;
        background: linear-gradient(90deg, transparent, var(--electric), transparent);
        opacity: 0;
        transition: opacity 0.3s;
    }

    .tri-block:hover {
        border-color: var(--electric);
        transform: translateY(-4px);
        box-shadow: 0 10px 30px -5px var(--glow);
    }

    .tri-block:hover::before {
        opacity: 1;
    }

    .tri-title {
        font-family: 'Orbitron', monospace;
        font-size: 0.7rem;
        color: var(--electric);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 240, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .tri-value {
        font-family: 'Orbitron', monospace;
        font-size: 2.5rem;
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 20px rgba(255, 214, 10, 0.5);
        min-height: 3rem;
        display: flex;
        align-items: center;
    }

    .info-label {
        font-size: 0.75rem;
        color: #94a3b8;
        margin-top: 10px;
    }

    .info-data {
        color: var(--electric);
        font-weight: 600;
    }

    /* VALIDATION PANEL */
    .validation-panel {
        grid-column: span 4;
        background: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        border: 2px solid var(--warning);
        border-radius: 16px;
        padding: 25px;
        margin-bottom: 20px;
    }

    .score-display {
        text-align: center;
        margin: 20px 0;
    }

    .score-circle {
        display: inline-block;
        width: 200px;
        height: 200px;
        border-radius: 50%;
        background: conic-gradient(var(--success) 0deg, var(--success) 0deg, rgba(255,255,255,0.1) 0deg);
        position: relative;
        transition: background 1s ease;
    }

    .score-value {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Orbitron', monospace;
        font-size: 3rem;
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 30px rgba(255, 214, 10, 0.8);
    }

    .comparison-table {
        margin-top: 20px;
        overflow-x: auto;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
    }

    th, td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid var(--border);
    }

    th {
        background: rgba(0, 240, 255, 0.1);
        color: var(--electric);
        font-weight: 700;
    }

    .chord-correct {
        color: var(--success);
        font-weight: 700;
    }

    .chord-wrong {
        color: var(--danger);
        font-weight: 700;
    }

    .chord-partial {
        color: var(--warning);
        font-weight: 700;
    }

    /* STATS */
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-top: 20px;
    }

    .stat-box {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid var(--border);
        text-align: center;
    }

    .stat-value {
        font-size: 2rem;
        font-weight: 900;
        color: var(--electric);
        margin-bottom: 5px;
    }

    .stat-label {
        font-size: 0.7rem;
        color: #94a3b8;
    }

    /* CONFIDENCE INDICATOR */
    .confidence-container {
        margin-top: 15px;
    }

    .conf-bar {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        overflow: hidden;
    }

    .conf-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--neon), var(--success));
        transition: width 0.4s;
        border-radius: 4px;
        box-shadow: 0 0 10px currentColor;
    }

    .conf-text {
        font-size: 0.7rem;
        color: var(--success);
        margin-top: 5px;
        text-align: right;
    }

    /* VISUALIZERS */
    canvas {
        width: 100%;
        height: 140px;
        background: var(--void);
        border-radius: 12px;
        border: 1px solid rgba(0, 240, 255, 0.2);
    }

    .chromagram {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        gap: 4px;
        margin-top: 10px;
    }

    .chroma-bar {
        height: 60px;
        background: rgba(0, 240, 255, 0.1);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
    }

    .chroma-fill {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: linear-gradient(180deg, var(--electric), var(--neon));
        transition: height 0.2s;
    }

    .chroma-label {
        position: absolute;
        bottom: 2px;
        width: 100%;
        text-align: center;
        font-size: 0.65rem;
        color: var(--text);
        font-weight: 600;
    }

    /* HARMONICS VISUALIZER */
    .harmonics-container {
        margin-top: 15px;
    }

    .harmonic-bar {
        height: 12px;
        background: rgba(0, 240, 255, 0.1);
        border-radius: 2px;
        margin: 2px 0;
        position: relative;
        overflow: hidden;
    }

    .harmonic-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--neon), var(--electric));
        transition: width 0.3s;
    }

    .harmonic-label {
        position: absolute;
        left: 5px;
        top: 0;
        font-size: 0.6rem;
        color: var(--text);
    }

    /* CONTROLS */
    input[type="file"] {
        width: 100%;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--text);
        cursor: pointer;
    }

    input[type="range"] {
        width: 100%;
        height: 6px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 3px;
        outline: none;
        margin: 10px 0;
        -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: var(--electric);
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 0 10px var(--glow);
    }

    audio {
        width: 100%;
        margin-top: 10px;
        border-radius: 8px;
        filter: invert(1) hue-rotate(180deg);
    }

    .btn-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }

    button {
        flex: 1;
        padding: 14px;
        border: none;
        border-radius: 8px;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--electric), #0066ff);
        color: var(--void);
        box-shadow: 0 4px 15px rgba(0, 240, 255, 0.3);
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 240, 255, 0.5);
    }

    .btn-danger {
        background: linear-gradient(135deg, var(--neon), #cc0055);
        color: white;
    }

    .btn-success {
        background: linear-gradient(135deg, var(--success), #059669);
        color: var(--void);
    }

    /* TIMELINE */
    .timeline-container {
        grid-column: span 4;
        background: rgba(10, 14, 39, 0.8);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
    }

    #chord-timeline {
        display: flex;
        gap: 6px;
        overflow-x: auto;
        padding: 15px;
        min-height: 80px;
        scrollbar-width: thin;
        scrollbar-color: var(--electric) var(--void);
        align-items: flex-end;
    }

    .chord-event {
        min-width: 100px;
        padding: 12px 16px;
        background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(255, 0, 110, 0.1));
        border: 1px solid var(--electric);
        border-left: 3px solid var(--neon);
        border-radius: 8px;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.9rem;
        color: var(--gold);
        text-align: center;
        animation: eventSlide 0.4s;
        cursor: pointer;
        transition: all 0.3s;
    }

    .chord-event.correct {
        border-color: var(--success);
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
    }

    .chord-event.wrong {
        border-color: var(--danger);
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
    }

    .chord-event.partial {
        border-color: var(--warning);
        background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(251, 191, 36, 0.1));
    }

    @keyframes eventSlide {
        from { opacity: 0; transform: translateX(30px) scale(0.8); }
        to { opacity: 1; transform: translateX(0) scale(1); }
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        font-size: 0.7rem;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #64748b;
        animation: pulse 2s infinite;
    }

    .status-dot.active {
        background: var(--success);
        box-shadow: 0 0 10px var(--success);
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    /* PROGRESS BAR */
    .progress-container {
        grid-column: span 4;
        margin-top: 10px;
    }

    .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 5px;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--neon), var(--electric));
        transition: width 0.3s;
    }

    /* ADVANCED INFO */
    .advanced-info {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-top: 15px;
    }

    .info-item {
        background: rgba(0, 0, 0, 0.2);
        padding: 8px;
        border-radius: 6px;
        border: 1px solid rgba(0, 240, 255, 0.1);
    }

    .info-item-label {
        font-size: 0.6rem;
        color: #94a3b8;
        margin-bottom: 2px;
    }

    .info-item-value {
        font-size: 0.8rem;
        color: var(--electric);
        font-weight: 600;
    }
</style>
</head>
<body>

<div class="container">
    <h1>
        ‚ö° TRI ULTIMATE ADVANCED CHORD RECOGNITION
        <span class="version">v5.4 ‚Ä¢ Mazmazika/Melodyne Inspired Algorithms</span>
    </h1>

    <!-- VALIDATION PANEL -->
    <div class="validation-panel">
        <div class="tri-title">
            <span>üìä ADVANCED VALIDATION - Tracy Chapman "Talkin' Bout a Revolution"</span>
        </div>
        
        <div class="score-display">
            <div class="score-circle" id="score-circle">
                <div class="score-value" id="score-value">0%</div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value" id="total-detected">0</div>
                <div class="stat-label">Detected Chords</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="correct-count" style="color: var(--success);">0</div>
                <div class="stat-label">Correct ‚úì</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="partial-count" style="color: var(--warning);">0</div>
                <div class="stat-label">Partial ~</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="wrong-count" style="color: var(--danger);">0</div>
                <div class="stat-label">Wrong ‚úó</div>
            </div>
        </div>

        <div class="comparison-table">
            <h3 style="color: var(--electric); margin: 20px 0 10px 0;">üìã Chord-by-Chord Comparison</h3>
            <table id="comparison-table">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Expected (Official)</th>
                        <th>Detected (TRI)</th>
                        <th>Match</th>
                        <th>Confidence</th>
                    </tr>
                </thead>
                <tbody id="comparison-tbody">
                    <tr>
                        <td colspan="5" style="text-align: center; color: #64748b;">
                            Start analysis to see results...
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="tri-grid">
        <!-- AUDIO SOURCE -->
        <div class="tri-block">
            <div class="tri-title">
                <span>üéµ AUDIO SOURCE</span>
            </div>
            <input type="file" id="audio-input" accept="audio/*">
            <audio id="audio-player" controls crossorigin="anonymous"></audio>
            <div class="progress-container">
                <div class="info-label">
                    Position: <span id="time-display" class="info-data">0.00s</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- SPECTRAL ANALYSIS -->
        <div class="tri-block">
            <div class="tri-title">
                <span>üìä SPECTRUM ANALYZER</span>
            </div>
            <canvas id="spectrum-canvas"></canvas>
            <div class="info-label">
                RMS Energy: <span id="energy-display" class="info-data">0 dB</span>
            </div>
        </div>

        <!-- CURRENT CHORD -->
        <div class="tri-block">
            <div class="tri-title">
                <span>üé∏ CURRENT CHORD</span>
            </div>
            <div id="chord-display" class="tri-value">--</div>
            <div class="confidence-container">
                <div class="conf-bar">
                    <div class="conf-fill" id="conf-fill" style="width: 0%"></div>
                </div>
                <div class="conf-text" id="conf-text">Confidence: 0%</div>
            </div>
            <div class="harmonics-container" id="harmonics-display">
                <!-- Harmonic visualization will be inserted here -->
            </div>
        </div>

        <!-- KEY DETECTION -->
        <div class="tri-block">
            <div class="tri-title">
                <span>üîë DETECTED KEY</span>
            </div>
            <div id="key-display" class="tri-value" style="font-size: 1.8rem; color: var(--success);">--</div>
            <div class="info-label">Expected: <span class="info-data">G Major</span></div>
            <div class="advanced-info">
                <div class="info-item">
                    <div class="info-item-label">Key Confidence</div>
                    <div class="info-item-value" id="key-confidence">0%</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Scale Type</div>
                    <div class="info-item-value" id="scale-type">--</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Tonic</div>
                    <div class="info-item-value" id="tonic-note">--</div>
                </div>
            </div>
        </div>

        <!-- CHROMAGRAM -->
        <div class="tri-block" style="grid-column: span 2;">
            <div class="tri-title">
                <span>üåà CHROMAGRAM & PITCH CLASS</span>
            </div>
            <div class="chromagram" id="chromagram"></div>
            <div class="advanced-info">
                <div class="info-item">
                    <div class="info-item-label">Strongest Note</div>
                    <div class="info-item-value" id="strongest-note">--</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Note Strength</div>
                    <div class="info-item-value" id="note-strength">0%</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Clarity</div>
                    <div class="info-item-value" id="pitch-clarity">0%</div>
                </div>
            </div>
        </div>

        <!-- ADVANCED SETTINGS -->
        <div class="tri-block" style="grid-column: span 2;">
            <div class="tri-title">
                <span>‚öôÔ∏è ADVANCED SETTINGS</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <label class="info-label">
                        Harmonic Sensitivity: <span id="harmonic-sens-val" class="info-data">0.8</span>
                    </label>
                    <input type="range" id="harmonic-sensitivity" min="0.1" max="1.5" step="0.1" value="0.8">
                </div>
                <div>
                    <label class="info-label">
                        Temporal Stability: <span id="temporal-stab-val" class="info-data">0.7</span>
                    </label>
                    <input type="range" id="temporal-stability" min="0.1" max="1.0" step="0.1" value="0.7">
                </div>
                <div>
                    <label class="info-label">
                        In-Key Priority: <span id="key-priority-val" class="info-data">2.0x</span>
                    </label>
                    <input type="range" id="key-priority" min="1.0" max="3.0" step="0.2" value="2.0">
                </div>
                <div>
                    <label class="info-label">
                        Min Duration: <span id="min-duration-val" class="info-data">0.8s</span>
                    </label>
                    <input type="range" id="min-duration" min="0.3" max="1.5" step="0.1" value="0.8">
                </div>
            </div>
            <div class="advanced-info" style="margin-top: 15px;">
                <div class="info-item">
                    <div class="info-item-label">Algorithm Mode</div>
                    <div class="info-item-value" id="algorithm-mode">Advanced</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Frame Rate</div>
                    <div class="info-item-value" id="frame-rate">0 fps</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Buffer Size</div>
                    <div class="info-item-value" id="buffer-size">16384</div>
                </div>
            </div>
        </div>

        <!-- CONTROLS -->
        <div class="tri-block" style="grid-column: span 4;">
            <div class="tri-title">
                <span>üéõÔ∏è ADVANCED ENGINE CONTROL</span>
            </div>
            <div class="btn-group">
                <button id="start-btn" class="btn-primary">üöÄ START ANALYSIS</button>
                <button id="validate-btn" class="btn-success">‚úì VALIDATE RESULTS</button>
                <button id="export-btn" class="btn-primary">üíæ EXPORT REPORT</button>
                <button id="stop-btn" class="btn-danger">‚èπÔ∏è STOP</button>
                <button id="reset-btn" class="btn-danger">üîÑ RESET</button>
                <button id="calibrate-btn" class="btn-primary">üéöÔ∏è CALIBRATE</button>
            </div>
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Ready to initialize</span>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="analysis-progress" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- ADVANCED METRICS -->
        <div class="tri-block" style="grid-column: span 4;">
            <div class="tri-title">
                <span>üìà ADVANCED METRICS</span>
            </div>
            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px;">
                <div>
                    <div class="info-label">Spectral Centroid</div>
                    <div class="info-data" id="centroid-display">0 Hz</div>
                </div>
                <div>
                    <div class="info-label">Harmonic Stability</div>
                    <div class="info-data" id="stability-display">0%</div>
                </div>
                <div>
                    <div class="info-label">Frame Count</div>
                    <div class="info-data" id="frame-display">0</div>
                </div>
                <div>
                    <div class="info-label">Tuning Offset</div>
                    <div class="info-data" id="tuning-offset">0¬¢</div>
                </div>
                <div>
                    <div class="info-label">Live Accuracy</div>
                    <div class="info-data" id="live-accuracy">0%</div>
                </div>
                <div>
                    <div class="info-label">Harmonic Ratio</div>
                    <div class="info-data" id="harmonic-ratio">0.0</div>
                </div>
            </div>
            <div class="advanced-info" style="margin-top: 15px;">
                <div class="info-item">
                    <div class="info-item-label">Chord Changes</div>
                    <div class="info-item-value" id="chord-changes">0</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Avg Confidence</div>
                    <div class="info-item-value" id="avg-confidence">0%</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Detection Speed</div>
                    <div class="info-item-value" id="detection-speed">0ms</div>
                </div>
            </div>
        </div>

        <!-- TIMELINE -->
        <div class="timeline-container">
            <div class="tri-title">
                <span>üìù CHORD TIMELINE (Advanced Detection with Harmonic Validation)</span>
            </div>
            <div id="chord-timeline"></div>
            <div class="advanced-info" style="margin-top: 15px;">
                <div class="info-item">
                    <div class="info-item-label">Timeline Length</div>
                    <div class="info-item-value" id="timeline-length">0 chords</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Current BPM</div>
                    <div class="info-item-value" id="current-bpm">120</div>
                </div>
                <div class="info-item">
                    <div class="info-item-label">Section</div>
                    <div class="info-item-value" id="current-section">Intro</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * TRI ULTIMATE v5.4 - ADVANCED CHORD RECOGNITION SYSTEM
 * Inspired by Mazmazika, Melodyne, and chords.ai algorithms
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

// OFFICIAL PROGRESSION - Tracy Chapman "Talkin' Bout a Revolution"
const OFFICIAL_PROGRESSION = {
    song: "Talkin' Bout a Revolution",
    artist: "Tracy Chapman",
    key: "G Major",
    bpm: 120,
    timeSignature: "4/4",
    
    // Structure temporelle (en secondes)
    structure: [
        // Intro (0-15s)
        { start: 0, end: 3.5, chord: "G Major", section: "Intro" },
        { start: 3.5, end: 7, chord: "C Major", section: "Intro" },
        { start: 7, end: 10.5, chord: "E minor", section: "Intro" },
        { start: 10.5, end: 14, chord: "D Major", section: "Intro" },
        
        // Couplet 1 (15-45s)
        { start: 14, end: 17, chord: "G Major", section: "Verse 1" },
        { start: 17, end: 20, chord: "C Major", section: "Verse 1" },
        { start: 20, end: 23, chord: "E minor", section: "Verse 1" },
        { start: 23, end: 26, chord: "D Major", section: "Verse 1" },
        { start: 26, end: 29, chord: "G Major", section: "Verse 1" },
        { start: 29, end: 32, chord: "C Major", section: "Verse 1" },
        { start: 32, end: 35, chord: "E minor", section: "Verse 1" },
        { start: 35, end: 38, chord: "D Major", section: "Verse 1" },
        { start: 38, end: 41, chord: "G Major", section: "Verse 1" },
        { start: 41, end: 44, chord: "C Major", section: "Verse 1" },
        
        // Refrain (45-60s)
        { start: 44, end: 47, chord: "E minor", section: "Chorus" },
        { start: 47, end: 50, chord: "D Major", section: "Chorus" },
        { start: 50, end: 53, chord: "G Major", section: "Chorus" },
        { start: 53, end: 56, chord: "C Major", section: "Chorus" },
        { start: 56, end: 59, chord: "E minor", section: "Chorus" },
        { start: 59, end: 62, chord: "D Major", section: "Chorus" },
        
        // Couplet 2 (60-90s)
        { start: 62, end: 65, chord: "G Major", section: "Verse 2" },
        { start: 65, end: 68, chord: "C Major", section: "Verse 2" },
        { start: 68, end: 71, chord: "E minor", section: "Verse 2" },
        { start: 71, end: 74, chord: "D Major", section: "Verse 2" },
        { start: 74, end: 77, chord: "G Major", section: "Verse 2" },
        { start: 77, end: 80, chord: "C Major", section: "Verse 2" },
        { start: 80, end: 83, chord: "E minor", section: "Verse 2" },
        { start: 83, end: 86, chord: "D Major", section: "Verse 2" },
        { start: 86, end: 89, chord: "G Major", section: "Verse 2" },
        { start: 89, end: 92, chord: "C Major", section: "Verse 2" },
        
        // Bridge/Outro (90s+)
        { start: 92, end: 95, chord: "E minor", section: "Outro" },
        { start: 95, end: 98, chord: "D Major", section: "Outro" },
        { start: 98, end: 101, chord: "G Major", section: "Outro" },
        { start: 101, end: 104, chord: "C Major", section: "Outro" },
        { start: 104, end: 107, chord: "E minor", section: "Outro" },
        { start: 107, end: 110, chord: "D Major", section: "Outro" },
        { start: 110, end: 113, chord: "G Major", section: "Outro" },
        { start: 113, end: 116, chord: "C Major", section: "Outro" },
        { start: 116, end: 119, chord: "E minor", section: "Outro" },
        { start: 119, end: 122, chord: "D Major", section: "Outro" },
        { start: 122, end: 999, chord: "G Major", section: "Outro" },
    ],
    
    // Accords valides dans la tonalit√©
    validChords: ["G Major", "C Major", "E minor", "D Major"],
    
    // Variations acceptables (mapping avanc√©)
    chordVariations: {
        "G Major": ["G", "Gmaj", "GM", "Gmaj7", "G6", "Gadd9", "Gsus4", "Gsus2"],
        "C Major": ["C", "Cmaj", "CM", "Cmaj7", "C6", "Cadd9", "Csus4", "Csus2"],
        "E minor": ["Em", "Emin", "Em7", "Emin7", "Em6", "Emin6"],
        "D Major": ["D", "Dmaj", "DM", "Dmaj7", "D6", "Dadd9", "Dsus4", "Dsus2"]
    }
};

// CONFIGURATION AVANC√âE
const CONFIG = {
    notes: ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
    
    // Templates am√©lior√©s inspir√©s de Melodyne
    templates: {
        'Major': { 
            profile: [1.00, 0.00, 0.00, 0.00, 0.95, 0.00, 0.00, 1.00, 0.00, 0.00, 0.00, 0.00], 
            scale: 'Major', 
            priority: 12,
            color: '#00ff88'
        },
        'minor': { 
            profile: [1.00, 0.00, 0.00, 0.92, 0.00, 0.00, 0.00, 0.98, 0.00, 0.00, 0.00, 0.00], 
            scale: 'Minor', 
            priority: 12,
            color: '#ff006e'
        },
        '7': { 
            profile: [1.00, 0.00, 0.00, 0.00, 0.90, 0.00, 0.00, 0.95, 0.00, 0.00, 0.85, 0.00], 
            scale: 'Dominant', 
            priority: 9,
            color: '#00f0ff'
        },
        'maj7': { 
            profile: [1.00, 0.00, 0.00, 0.00, 0.90, 0.00, 0.00, 0.95, 0.00, 0.00, 0.00, 0.88], 
            scale: 'Major', 
            priority: 8,
            color: '#00ccff'
        },
        'm7': { 
            profile: [1.00, 0.00, 0.00, 0.88, 0.00, 0.00, 0.00, 0.95, 0.00, 0.00, 0.82, 0.00], 
            scale: 'Minor', 
            priority: 8,
            color: '#ff66aa'
        },
        'sus4': { 
            profile: [1.00, 0.00, 0.00, 0.00, 0.00, 0.95, 0.00, 1.00, 0.00, 0.00, 0.00, 0.00], 
            scale: 'Suspended', 
            priority: 7,
            color: '#ffaa00'
        },
        'sus2': { 
            profile: [1.00, 0.00, 0.88, 0.00, 0.00, 0.00, 0.00, 0.98, 0.00, 0.00, 0.00, 0.00], 
            scale: 'Suspended', 
            priority: 7,
            color: '#ffcc00'
        },
        'dim': { 
            profile: [1.00, 0.00, 0.00, 0.88, 0.00, 0.00, 0.85, 0.00, 0.00, 0.00, 0.00, 0.00], 
            scale: 'Diminished', 
            priority: 5,
            color: '#9900ff'
        },
        'aug': { 
            profile: [1.00, 0.00, 0.00, 0.00, 0.88, 0.00, 0.00, 0.00, 0.90, 0.00, 0.00, 0.00], 
            scale: 'Augmented', 
            priority: 5,
            color: '#ff00ff'
        }
    },
    
    // Profils d'√©chelle pour la d√©tection de tonalit√©
    scaleProfiles: {
        major: [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88],
        minor: [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17],
        harmonicMinor: [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
    },
    
    // Intervalles d'√©chelle
    scaleIntervals: {
        major: [0, 2, 4, 5, 7, 9, 11],
        minor: [0, 2, 3, 5, 7, 8, 10],
        harmonicMinor: [0, 2, 3, 5, 7, 8, 11]
    },
    
    // Param√®tres audio
    fftSize: 16384,
    smoothing: 0.8,
    minFreq: 65,    // Fr√©quence minimale pour guitare (E2)
    maxFreq: 1320,  // Fr√©quence maximale pour guitare (E6)
    sampleRate: 44100,
    
    // Param√®tres de d√©tection
    harmonicTolerance: 0.008,  // Tol√©rance pour les harmoniques
    peakThreshold: 0.15,       // Seuil pour les pics spectraux
    minHarmonicCount: 3,       // Nombre minimum d'harmoniques
    
    // Param√®tres temporels
    stabilityThreshold: 10,     // Nombre de frames pour stabilit√©
    minChordDuration: 0.8,      // Dur√©e minimum d'un accord (secondes)
    maxChordChanges: 4,         // Changements max par seconde
    
    // R√©f√©rence
    referenceA: 440,
    fineTuneCents: 0,
    
    // Zones fr√©quentielles pond√©r√©es
    frequencyZones: [
        { min: 65, max: 250, weight: 4.0, name: "Bass (Fundamentals)" },
        { min: 250, max: 600, weight: 2.5, name: "Low Mids" },
        { min: 600, max: 1200, weight: 1.5, name: "High Mids" },
        { min: 1200, max: 3500, weight: 0.8, name: "Highs" }
    ]
};

// STATE GLOBAL AVANC√â
const state = {
    // Audio context
    audioCtx: null,
    analyser: null,
    source: null,
    isRunning: false,
    
    // M√©triques temporelles
    frameCount: 0,
    lastFrameTime: 0,
    fps: 0,
    analysisStartTime: 0,
    
    // D√©tection d'accord
    currentChord: null,
    lastChord: null,
    chordStability: 0,
    chordConfidence: 0,
    chordHistory: [],
    
    // Profil tonal
    pitchProfile: new Array(12).fill(0),
    keyProfile: new Array(12).fill(0),
    detectedKey: null,
    detectedScale: null,
    keyConfidence: 0,
    
    // Validation
    validationResults: [],
    correctCount: 0,
    partialCount: 0,
    wrongCount: 0,
    
    // Statistiques
    stats: {
        totalChords: 0,
        avgConfidence: 0,
        detectionTimes: [],
        harmonicRatios: []
    },
    
    // Validateur d'accords
    chordValidator: null,
    
    // Historique temporel
    temporalBuffer: {
        chords: [],
        profiles: [],
        timestamps: []
    }
};

// UI ELEMENTS
const UI = {
    // Audio elements
    player: document.getElementById('audio-player'),
    spectrumCanvas: document.getElementById('spectrum-canvas'),
    chromagram: document.getElementById('chromagram'),
    timeline: document.getElementById('chord-timeline'),
    harmonicsDisplay: document.getElementById('harmonics-display'),
    
    // Displays
    chordDisplay: document.getElementById('chord-display'),
    keyDisplay: document.getElementById('key-display'),
    timeDisplay: document.getElementById('time-display'),
    progressFill: document.getElementById('progress-fill'),
    
    // Confidence
    confFill: document.getElementById('conf-fill'),
    confText: document.getElementById('conf-text'),
    
    // Metrics
    energyDisplay: document.getElementById('energy-display'),
    centroidDisplay: document.getElementById('centroid-display'),
    stabilityDisplay: document.getElementById('stability-display'),
    frameDisplay: document.getElementById('frame-display'),
    tuningOffsetDisplay: document.getElementById('tuning-offset'),
    liveAccuracyDisplay: document.getElementById('live-accuracy'),
    harmonicRatioDisplay: document.getElementById('harmonic-ratio'),
    
    // Status
    statusDot: document.getElementById('status-dot'),
    statusText: document.getElementById('status-text'),
    analysisProgress: document.getElementById('analysis-progress'),
    
    // Advanced displays
    keyConfidenceDisplay: document.getElementById('key-confidence'),
    scaleTypeDisplay: document.getElementById('scale-type'),
    tonicNoteDisplay: document.getElementById('tonic-note'),
    strongestNoteDisplay: document.getElementById('strongest-note'),
    noteStrengthDisplay: document.getElementById('note-strength'),
    pitchClarityDisplay: document.getElementById('pitch-clarity'),
    chordChangesDisplay: document.getElementById('chord-changes'),
    avgConfidenceDisplay: document.getElementById('avg-confidence'),
    detectionSpeedDisplay: document.getElementById('detection-speed'),
    timelineLengthDisplay: document.getElementById('timeline-length'),
    currentBPMDisplay: document.getElementById('current-bpm'),
    currentSectionDisplay: document.getElementById('current-section'),
    frameRateDisplay: document.getElementById('frame-rate'),
    algorithmModeDisplay: document.getElementById('algorithm-mode'),
    bufferSizeDisplay: document.getElementById('buffer-size'),
    
    // Sliders
    harmonicSensSlider: document.getElementById('harmonic-sensitivity'),
    temporalStabSlider: document.getElementById('temporal-stability'),
    keyPrioritySlider: document.getElementById('key-priority'),
    minDurationSlider: document.getElementById('min-duration'),
    
    // Validation UI
    scoreCircle: document.getElementById('score-circle'),
    scoreValue: document.getElementById('score-value'),
    totalDetected: document.getElementById('total-detected'),
    correctCount: document.getElementById('correct-count'),
    partialCount: document.getElementById('partial-count'),
    wrongCount: document.getElementById('wrong-count'),
    comparisonTbody: document.getElementById('comparison-tbody')
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CLASSES AVANC√âES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ChordValidator {
    constructor() {
        this.history = [];
        this.minDuration = 0.8;
        this.confidenceThreshold = 0.6;
        this.maxHistorySize = 50;
    }
    
    validateChange(newChord, timestamp, confidence) {
        if (this.history.length === 0) {
            this.history.push({ 
                chord: newChord, 
                timestamp, 
                confidence,
                duration: 0
            });
            return true;
        }
        
        const last = this.history[this.history.length - 1];
        const duration = timestamp - last.timestamp;
        
        // V√©rifier la dur√©e minimale
        if (duration < this.minDuration) {
            return false;
        }
        
        // V√©rifier le seuil de confiance
        if (confidence < this.confidenceThreshold * 100) {
            return false;
        }
        
        // Mettre √† jour la dur√©e de l'accord pr√©c√©dent
        last.duration = duration;
        
        // Ajouter le nouvel accord
        this.history.push({ 
            chord: newChord, 
            timestamp, 
            confidence,
            duration: 0
        });
        
        // Limiter la taille de l'historique
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
        }
        
        return true;
    }
    
    getCurrentChord() {
        return this.history.length > 0 ? this.history[this.history.length - 1] : null;
    }
    
    getChordHistory() {
        return this.history;
    }
    
    updateMinDuration(duration) {
        this.minDuration = duration;
    }
}

class HarmonicAnalyzer {
    constructor() {
        this.harmonicSeries = [];
        this.fundamental = 0;
        this.strength = 0;
    }
    
    analyze(fundamentals, spectrum, sampleRate, binWidth) {
        this.harmonicSeries = [];
        
        if (fundamentals.length === 0) {
            return { fundamental: 0, harmonics: [], strength: 0 };
        }
        
        // Trouver la fondamentale la plus forte
        let strongestFundamental = fundamentals[0];
        for (const fund of fundamentals) {
            if (fund.magnitude > strongestFundamental.magnitude) {
                strongestFundamental = fund;
            }
        }
        
        this.fundamental = strongestFundamental.freq;
        let totalHarmonicEnergy = 0;
        
        // Analyser les 8 premi√®res harmoniques
        for (let h = 1; h <= 8; h++) {
            const expectedFreq = this.fundamental * h;
            const expectedBin = Math.round(expectedFreq / binWidth);
            
            let maxMag = 0;
            let actualFreq = expectedFreq;
            
            // Rechercher autour de la fr√©quence attendue
            for (let offset = -5; offset <= 5; offset++) {
                const bin = expectedBin + offset;
                if (bin >= 0 && bin < spectrum.length) {
                    if (spectrum[bin] > maxMag) {
                        maxMag = spectrum[bin];
                        actualFreq = bin * binWidth;
                    }
                }
            }
            
            if (maxMag > 0) {
                const deviation = Math.abs(actualFreq - expectedFreq) / expectedFreq;
                const score = maxMag * (1 - deviation * 10);
                
                this.harmonicSeries.push({
                    harmonic: h,
                    frequency: actualFreq,
                    expectedFreq: expectedFreq,
                    magnitude: maxMag,
                    deviation: deviation,
                    score: score
                });
                
                totalHarmonicEnergy += score;
            }
        }
        
        this.strength = totalHarmonicEnergy / Math.max(1, this.harmonicSeries.length);
        return {
            fundamental: this.fundamental,
            harmonics: this.harmonicSeries,
            strength: this.strength
        };
    }
    
    getHarmonicRatio() {
        if (this.harmonicSeries.length < 2) return 0;
        
        let ratioSum = 0;
        for (let i = 1; i < this.harmonicSeries.length; i++) {
            const ratio = this.harmonicSeries[i].magnitude / this.harmonicSeries[0].magnitude;
            ratioSum += ratio;
        }
        
        return ratioSum / (this.harmonicSeries.length - 1);
    }
}

class KeyDetector {
    constructor() {
        this.keyHistory = new Array(12).fill(0);
        this.keyConfidence = 0;
        this.currentKey = null;
    }
    
    detectKey(pitchProfile) {
        // Mettre √† jour l'historique
        for (let i = 0; i < 12; i++) {
            this.keyHistory[i] = this.keyHistory[i] * 0.9 + pitchProfile[i] * 0.1;
        }
        
        const totalEnergy = this.keyHistory.reduce((a, b) => a + b, 0);
        if (totalEnergy === 0) return null;
        
        const normalized = this.keyHistory.map(v => v / totalEnergy);
        
        let bestCorrelation = -Infinity;
        let bestKey = { root: 0, scale: 'Major', confidence: 0 };
        
        // Tester toutes les racines et √©chelles
        for (let root = 0; root < 12; root++) {
            // Majeur
            let corrMajor = this.calculateCorrelation(normalized, root, 'major');
            if (corrMajor > bestCorrelation) {
                bestCorrelation = corrMajor;
                bestKey = { root, scale: 'Major', confidence: corrMajor };
            }
            
            // Mineur
            let corrMinor = this.calculateCorrelation(normalized, root, 'minor');
            if (corrMinor > bestCorrelation) {
                bestCorrelation = corrMinor;
                bestKey = { root, scale: 'minor', confidence: corrMinor };
            }
        }
        
        this.keyConfidence = bestCorrelation;
        this.currentKey = bestKey;
        
        return bestKey;
    }
    
    calculateCorrelation(normalized, root, scaleType) {
        const profile = CONFIG.scaleProfiles[scaleType];
        let correlation = 0;
        
        for (let i = 0; i < 12; i++) {
            const profileIndex = (i + root) % 12;
            correlation += normalized[i] * profile[profileIndex];
        }
        
        return correlation;
    }
    
    getKeyName() {
        if (!this.currentKey) return '--';
        return CONFIG.notes[this.currentKey.root] + ' ' + this.currentKey.scale;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FONCTIONS DE BASE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Fonction pour normaliser les noms d'accords
function normalizeChordName(chordName) {
    if (!chordName) return '';
    
    const parts = chordName.split(' ');
    if (parts.length < 2) return chordName;
    
    const root = parts[0];
    const type = parts.slice(1).join(' ');
    
    // Mapper les variations vers les types de base
    const typeMapping = {
        '7': 'Major',
        'maj7': 'Major',
        'maj': 'Major',
        'M7': 'Major',
        'M': 'Major',
        '6': 'Major',
        'add9': 'Major',
        'sus4': 'Major',
        'sus2': 'Major',
        '9': 'Major',
        '11': 'Major',
        '13': 'Major',
        'm7': 'minor',
        'min7': 'minor',
        'm': 'minor',
        'min': 'minor',
        'm6': 'minor',
        'm9': 'minor'
    };
    
    // V√©rifier chaque mapping
    for (const [ext, baseType] of Object.entries(typeMapping)) {
        if (type.includes(ext)) {
            return root + ' ' + baseType;
        }
    }
    
    return chordName;
}

// Fonction pour obtenir l'accord attendu
function getExpectedChord(timestamp) {
    for (let segment of OFFICIAL_PROGRESSION.structure) {
        if (timestamp >= segment.start && timestamp < segment.end) {
            return {
                chord: segment.chord,
                section: segment.section
            };
        }
    }
    return null;
}

// Fonction pour comparer les accords
function compareChords(detected, expected) {
    if (!expected) return 'unknown';
    
    const normDetected = detected.trim();
    const normExpected = expected.chord.trim();
    
    // Match exact
    if (normDetected === normExpected) return 'correct';
    
    // Normalisation
    const normDetectedBase = normalizeChordName(normDetected);
    const normExpectedBase = normalizeChordName(normExpected);
    
    // Match apr√®s normalisation
    if (normDetectedBase === normExpectedBase) return 'correct';
    
    // Extraire les racines
    const detectParts = normDetected.split(' ');
    const expectParts = normExpected.split(' ');
    
    if (detectParts.length === 0 || expectParts.length === 0) return 'wrong';
    
    const detectRoot = detectParts[0];
    const expectRoot = expectParts[0];
    
    // Racines diff√©rentes -> wrong
    if (detectRoot !== expectRoot) return 'wrong';
    
    // M√™me racine, type diff√©rent -> partial
    return 'partial';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FONCTIONS DE D√âTECTION AVANC√âES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// D√©tection des fondamentales avec validation harmonique
function detectFundamentalsWithHarmonics(spectrum) {
    const sampleRate = state.audioCtx.sampleRate;
    const binWidth = sampleRate / CONFIG.fftSize;
    const sensitivity = parseFloat(UI.harmonicSensSlider.value);
    
    let candidates = [];
    
    // Analyser la plage de fr√©quences pertinente
    for (let i = Math.floor(CONFIG.minFreq / binWidth); i < Math.ceil(CONFIG.maxFreq / binWidth); i++) {
        const freq = i * binWidth;
        const magnitude = spectrum[i];
        
        // Seuil adaptatif bas√© sur la moyenne locale
        const localWindow = 10;
        let localSum = 0;
        let localCount = 0;
        
        for (let j = Math.max(0, i - localWindow); j <= Math.min(spectrum.length - 1, i + localWindow); j++) {
            localSum += spectrum[j];
            localCount++;
        }
        
        const localAvg = localSum / localCount;
        const threshold = localAvg * (1.5 + sensitivity);
        
        // D√©tection de pic
        if (magnitude > threshold && 
            magnitude > spectrum[i-1] && magnitude > spectrum[i+1] &&
            magnitude > spectrum[i-2] && magnitude > spectrum[i+2]) {
            
            // Calculer le score harmonique
            let harmonicScore = 0;
            let harmonicCount = 0;
            
            // V√©rifier les harmoniques 2, 3, 4, 5
            for (let h = 2; h <= 5; h++) {
                const harmonicFreq = freq * h;
                const harmonicBin = Math.round(harmonicFreq / binWidth);
                
                if (harmonicBin < spectrum.length) {
                    // Recherche locale autour de l'harmonique attendue
                    let maxHarmonic = 0;
                    for (let offset = -2; offset <= 2; offset++) {
                        const bin = harmonicBin + offset;
                        if (bin >= 0 && bin < spectrum.length) {
                            maxHarmonic = Math.max(maxHarmonic, spectrum[bin]);
                        }
                    }
                    
                    if (maxHarmonic > localAvg * 1.2) {
                        // Bonus si l'harmonique est pr√©sente
                        const ratio = maxHarmonic / magnitude;
                        harmonicScore += ratio * (1 / h); // Poids d√©croissant
                        harmonicCount++;
                    }
                }
            }
            
            // Score final avec bonus harmonique
            const score = magnitude * (1 + harmonicScore * 2);
            
            candidates.push({
                freq: freq,
                magnitude: magnitude,
                bin: i,
                harmonicCount: harmonicCount,
                harmonicScore: harmonicScore,
                score: score
            });
        }
    }
    
    // Trier par score et √©liminer les doublons
    candidates.sort((a, b) => b.score - a.score);
    
    let fundamentals = [];
    for (let candidate of candidates) {
        let isDuplicate = false;
        
        for (let fund of fundamentals) {
            const ratio = candidate.freq / fund.freq;
            if (ratio > 0.95 && ratio < 1.05) {
                isDuplicate = true;
                break;
            }
        }
        
        if (!isDuplicate) {
            fundamentals.push(candidate);
        }
        
        if (fundamentals.length >= 6) break;
    }
    
    return fundamentals;
}

// Cr√©ation du profil chromatique am√©lior√©
function createEnhancedPitchProfile(fundamentals, spectrum) {
    const pitchProfile = new Array(12).fill(0);
    const sampleRate = state.audioCtx.sampleRate;
    const binWidth = sampleRate / CONFIG.fftSize;
    
    // Analyser tout le spectre avec pond√©ration par zone
    for (let i = 0; i < spectrum.length; i++) {
        const freq = i * binWidth;
        let magnitude = spectrum[i];
        
        // Appliquer la pond√©ration de zone
        let weight = 1.0;
        for (const zone of CONFIG.frequencyZones) {
            if (freq >= zone.min && freq < zone.max) {
                weight = zone.weight;
                break;
            }
        }
        
        // Convertir en note avec v√©rification de justesse
        const noteIndex = freqToNoteIndex(freq);
        if (noteIndex !== -1) {
            // Bonus pour les fr√©quences proches des fondamentales d√©tect√©es
            let fundamentalBonus = 1.0;
            for (const fund of fundamentals) {
                const ratio = freq / fund.freq;
                if (ratio > 0.98 && ratio < 1.02) {
                    fundamentalBonus = 2.0;
                    break;
                }
            }
            
            pitchProfile[noteIndex] += magnitude * weight * fundamentalBonus;
        }
    }
    
    // Normaliser et appliquer un lissage
    const maxVal = Math.max(...pitchProfile);
    if (maxVal > 0) {
        for (let i = 0; i < 12; i++) {
            pitchProfile[i] = Math.pow(pitchProfile[i] / maxVal, 1.5);
        }
    }
    
    // Trouver la note la plus forte pour l'affichage
    let strongestIndex = 0;
    let strongestValue = 0;
    for (let i = 0; i < 12; i++) {
        if (pitchProfile[i] > strongestValue) {
            strongestValue = pitchProfile[i];
            strongestIndex = i;
        }
    }
    
    // Mettre √† jour l'UI
    UI.strongestNoteDisplay.textContent = CONFIG.notes[strongestIndex];
    UI.noteStrengthDisplay.textContent = (strongestValue * 100).toFixed(0) + '%';
    
    // Calculer la clart√© du pitch
    const totalEnergy = pitchProfile.reduce((a, b) => a + b, 0);
    const clarity = totalEnergy > 0 ? 
        (strongestValue / totalEnergy) * 100 : 0;
    UI.pitchClarityDisplay.textContent = clarity.toFixed(0) + '%';
    
    return pitchProfile;
}

// D√©tection d'accord avec contexte tonal
function detectChordWithContext(pitchProfile, keyInfo) {
    const candidates = [];
    const keyPriority = parseFloat(UI.keyPrioritySlider.value);
    
    for (let rootIndex = 0; rootIndex < 12; rootIndex++) {
        for (let chordType in CONFIG.templates) {
            const template = CONFIG.templates[chordType];
            let score = 0;
            
            // Calcul de la correspondance au template
            for (let i = 0; i < 12; i++) {
                const templateIndex = (i - rootIndex + 12) % 12;
                score += pitchProfile[i] * template.profile[templateIndex];
            }
            
            // Appliquer la priorit√© du type d'accord
            score *= (template.priority / 10);
            
            // Bonus pour les accords dans la tonalit√©
            if (keyInfo && keyInfo.root !== null) {
                if (isChordInKey(rootIndex, keyInfo.root, keyInfo.scale)) {
                    score *= keyPriority;
                } else {
                    score *= 0.3; // P√©nalit√© pour les accords hors tonalit√©
                }
            }
            
            // Bonus pour les accords de la progression attendue
            const chordName = CONFIG.notes[rootIndex] + ' ' + chordType;
            const normalizedName = normalizeChordName(chordName);
            
            if (OFFICIAL_PROGRESSION.validChords.some(expected => 
                normalizeChordName(expected) === normalizedName)) {
                score *= 1.5;
            }
            
            candidates.push({
                root: rootIndex,
                type: chordType,
                score: score,
                name: chordName,
                normalized: normalizedName
            });
        }
    }
    
    // Trier et retourner les meilleurs candidats
    candidates.sort((a, b) => b.score - a.score);
    
    // Retourner les 3 meilleurs pour debug
    return {
        best: candidates[0],
        alternatives: candidates.slice(1, 3)
    };
}

// V√©rifier si un accord est dans la tonalit√©
function isChordInKey(chordRoot, keyRoot, keyScale) {
    if (keyRoot === null || keyScale === null) return true;
    
    const scaleType = keyScale.toLowerCase();
    const scaleIntervals = CONFIG.scaleIntervals[scaleType];
    
    if (!scaleIntervals) return true;
    
    const relativePosition = (chordRoot - keyRoot + 12) % 12;
    return scaleIntervals.includes(relativePosition);
}

// Conversion fr√©quence -> note
function freqToNoteIndex(freq) {
    if (freq < CONFIG.minFreq || freq > CONFIG.maxFreq) return -1;
    
    // Calcul MIDI pr√©cis
    const midi = 12 * Math.log2(freq / CONFIG.referenceA) + 69;
    const cents = (midi - Math.round(midi)) * 100;
    
    // Mettre √† jour l'affichage du tuning
    if (Math.abs(cents) > 5) {
        UI.tuningOffsetDisplay.textContent = cents.toFixed(0) + '¬¢';
        UI.tuningOffsetDisplay.style.color = Math.abs(cents) > 20 ? 'var(--danger)' : 'var(--warning)';
    } else {
        UI.tuningOffsetDisplay.textContent = '0¬¢';
        UI.tuningOffsetDisplay.style.color = 'var(--success)';
    }
    
    return (Math.round(midi) + 12) % 12;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FONCTIONS DE VISUALISATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Dessiner le spectre
function drawSpectrum(spectrum) {
    const canvas = UI.spectrumCanvas;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    // Fond gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, 'rgba(0, 240, 255, 0.1)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Dessiner les barres
    const barCount = 200;
    const barWidth = width / barCount;
    
    for (let i = 0; i < barCount; i++) {
        const value = spectrum[Math.floor(i * spectrum.length / barCount)] / 255;
        const barHeight = Math.pow(value, 0.7) * height;
        
        // Gradient de couleur bas√© sur la fr√©quence
        const hue = 200 + (i / barCount) * 100;
        const saturation = 70 + value * 30;
        const lightness = 30 + value * 40;
        
        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        
        // Barre avec arrondi
        ctx.beginPath();
        ctx.roundRect(i * barWidth, height - barHeight, barWidth - 1, barHeight, 2);
        ctx.fill();
    }
    
    // Ligne de seuil
    const avg = spectrum.reduce((a, b) => a + b, 0) / spectrum.length / 255;
    const thresholdY = height * (1 - avg);
    
    ctx.strokeStyle = 'rgba(255, 0, 110, 0.5)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(0, thresholdY);
    ctx.lineTo(width, thresholdY);
    ctx.stroke();
    ctx.setLineDash([]);
}

// Mettre √† jour le chromagramme
function updateChromagram(pitchProfile) {
    if (!UI.chromagram.firstChild) {
        for (let i = 0; i < 12; i++) {
            const bar = document.createElement('div');
            bar.className = 'chroma-bar';
            bar.innerHTML = `
                <div class="chroma-fill"></div>
                <div class="chroma-label">${CONFIG.notes[i]}</div>
            `;
            UI.chromagram.appendChild(bar);
        }
    }
    
    const bars = UI.chromagram.querySelectorAll('.chroma-fill');
    for (let i = 0; i < 12; i++) {
        const height = pitchProfile[i] * 100;
        bars[i].style.height = height + '%';
        
        // Couleur bas√©e sur l'intensit√©
        const intensity = pitchProfile[i];
        bars[i].style.background = `linear-gradient(180deg, 
            hsla(200, 80%, ${50 + intensity * 30}%, 0.8),
            hsla(330, 80%, ${40 + intensity * 40}%, 0.6)
        )`;
    }
}

// Visualiser les harmoniques
function visualizeHarmonics(harmonicAnalysis) {
    UI.harmonicsDisplay.innerHTML = '';
    
    if (!harmonicAnalysis || harmonicAnalysis.harmonics.length === 0) {
        return;
    }
    
    const maxMag = Math.max(...harmonicAnalysis.harmonics.map(h => h.magnitude));
    
    harmonicAnalysis.harmonics.forEach(harmonic => {
        const bar = document.createElement('div');
        bar.className = 'harmonic-bar';
        
        const fill = document.createElement('div');
        fill.className = 'harmonic-fill';
        const width = (harmonic.magnitude / maxMag) * 100;
        fill.style.width = width + '%';
        
        const label = document.createElement('div');
        label.className = 'harmonic-label';
        label.textContent = `H${harmonic.harmonic}: ${harmonic.frequency.toFixed(0)}Hz`;
        
        bar.appendChild(fill);
        bar.appendChild(label);
        UI.harmonicsDisplay.appendChild(bar);
    });
    
    // Mettre √† jour le ratio harmonique
    let ratioSum = 0;
    let validCount = 0;
    
    harmonicAnalysis.harmonics.forEach(harmonic => {
        if (harmonic.harmonic > 1) {
            ratioSum += harmonic.magnitude / harmonicAnalysis.harmonics[0].magnitude;
            validCount++;
        }
    });
    
    const avgRatio = validCount > 0 ? ratioSum / validCount : 0;
    UI.harmonicRatioDisplay.textContent = avgRatio.toFixed(2);
}

// Ajouter √† la timeline
function addToTimeline(chord, timestamp, confidence) {
    if (state.chordHistory.length > 0) {
        const lastEntry = state.chordHistory[state.chordHistory.length - 1];
        
        // √âviter les doublons
        if (lastEntry.chord === chord) return;
        
        // √âviter les changements trop rapides
        if (timestamp - lastEntry.timestamp < CONFIG.minChordDuration / 2) return;
    }
    
    // Ajouter √† l'historique
    state.chordHistory.push({ 
        chord, 
        timestamp, 
        confidence,
        frame: state.frameCount
    });
    
    // Obtenir l'accord attendu
    const expected = getExpectedChord(timestamp);
    const matchType = compareChords(chord, expected ? expected.chord : null);
    
    // Cr√©er l'√©v√©nement de timeline
    const event = document.createElement('div');
    event.className = `chord-event ${matchType}`;
    event.innerHTML = `
        <div style="font-size: 0.9rem; font-weight: bold;">${chord}</div>
        <div class="chord-duration" style="font-size: 0.55rem; opacity: 0.8;">
            ${timestamp.toFixed(1)}s | ${expected ? expected.chord : 'N/A'}<br>
            ${matchType.toUpperCase()} (${confidence.toFixed(0)}%)
        </div>
    `;
    
    UI.timeline.appendChild(event);
    UI.timeline.scrollLeft = UI.timeline.scrollWidth;
    
    // Mettre √† jour les statistiques en temps r√©el
    if (matchType === 'correct') state.correctCount++;
    else if (matchType === 'partial') state.partialCount++;
    else if (matchType === 'wrong') state.wrongCount++;
    
    const total = state.chordHistory.length;
    const accuracy = total > 0 ? (state.correctCount / total) * 100 : 0;
    UI.liveAccuracyDisplay.textContent = accuracy.toFixed(0) + '%';
    
    // Mettre √† jour l'affichage de la timeline
    UI.timelineLengthDisplay.textContent = total + ' chords';
    
    // Limiter la taille de l'historique
    if (state.chordHistory.length > 100) {
        state.chordHistory.shift();
        if (UI.timeline.firstChild) {
            UI.timeline.removeChild(UI.timeline.firstChild);
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FONCTIONS DE VALIDATION ET RAPPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function validateResults() {
    UI.comparisonTbody.innerHTML = '';
    
    state.correctCount = 0;
    state.partialCount = 0;
    state.wrongCount = 0;
    
    let totalConfidence = 0;
    
    state.chordHistory.forEach(entry => {
        const expected = getExpectedChord(entry.timestamp);
        const expectedChord = expected ? expected.chord : null;
        const matchType = compareChords(entry.chord, expectedChord);
        
        if (matchType === 'correct') state.correctCount++;
        else if (matchType === 'partial') state.partialCount++;
        else if (matchType === 'wrong') state.wrongCount++;
        
        totalConfidence += entry.confidence;
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${entry.timestamp.toFixed(1)}s</td>
            <td>${expectedChord || 'N/A'}</td>
            <td>${entry.chord}</td>
            <td class="chord-${matchType}">${matchType.toUpperCase()}</td>
            <td>${entry.confidence.toFixed(0)}%</td>
        `;
        UI.comparisonTbody.appendChild(row);
    });
    
    // Mettre √† jour les moyennes
    const avgConf = state.chordHistory.length > 0 ? 
        totalConfidence / state.chordHistory.length : 0;
    UI.avgConfidenceDisplay.textContent = avgConf.toFixed(0) + '%';
    
    updateValidationUI();
}

function updateValidationUI() {
    const total = state.chordHistory.length;
    const accuracy = total > 0 ? (state.correctCount / total) * 100 : 0;
    
    UI.totalDetected.textContent = total;
    UI.correctCount.textContent = state.correctCount;
    UI.partialCount.textContent = state.partialCount;
    UI.wrongCount.textContent = state.wrongCount;
    
    UI.scoreValue.textContent = accuracy.toFixed(1) + '%';
    
    // Mettre √† jour le cercle de score
    const degrees = (accuracy / 100) * 360;
    let color = accuracy >= 80 ? 'var(--success)' : accuracy >= 50 ? 'var(--warning)' : 'var(--danger)';
    UI.scoreCircle.style.background = `conic-gradient(${color} ${degrees}deg, rgba(255,255,255,0.1) ${degrees}deg)`;
    
    // Mettre √† jour la pr√©cision en direct
    UI.liveAccuracyDisplay.textContent = accuracy.toFixed(0) + '%';
    
    // Mettre √† jour le nombre de changements d'accords
    UI.chordChangesDisplay.textContent = state.chordHistory.length;
}

function exportReport() {
    if (state.chordHistory.length === 0) {
        alert('No data to export!');
        return;
    }
    
    const total = state.chordHistory.length;
    const accuracy = total > 0 ? (state.correctCount / total) * 100 : 0;
    let totalConfidence = 0;
    
    let report = `TRI ULTIMATE v5.4 - ADVANCED VALIDATION REPORT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Song: ${OFFICIAL_PROGRESSION.song}
Artist: ${OFFICIAL_PROGRESSION.artist}
Expected Key: ${OFFICIAL_PROGRESSION.key}
Date: ${new Date().toLocaleString()}
Algorithm Version: Advanced Harmonic Detection v5.4

DETECTION PARAMETERS:
- Harmonic Sensitivity: ${UI.harmonicSensSlider.value}
- Temporal Stability: ${UI.temporalStabSlider.value}
- In-Key Priority: ${UI.keyPrioritySlider.value}x
- Minimum Chord Duration: ${UI.minDurationSlider.value}s

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
OVERALL STATISTICS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Total Chords Detected: ${total}
Correct: ${state.correctCount} (${(state.correctCount/total*100).toFixed(1)}%)
Partial: ${state.partialCount} (${(state.partialCount/total*100).toFixed(1)}%)
Wrong: ${state.wrongCount} (${(state.wrongCount/total*100).toFixed(1)}%)

ACCURACY SCORE: ${accuracy.toFixed(2)}%

DETECTED KEY: ${state.detectedKey !== null ? 
    CONFIG.notes[state.detectedKey] + ' ' + state.detectedScale : 'Not detected'}
KEY CONFIDENCE: ${state.keyConfidence.toFixed(2)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DETAILED CHORD-BY-CHORD COMPARISON
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Time\tExpected\tDetected\tMatch\tConfidence\tSection
`;
    
    state.chordHistory.forEach(entry => {
        const expected = getExpectedChord(entry.timestamp);
        const expectedChord = expected ? expected.chord : 'N/A';
        const section = expected ? expected.section : 'Unknown';
        const matchType = compareChords(entry.chord, expectedChord);
        
        totalConfidence += entry.confidence;
        
        report += `${entry.timestamp.toFixed(2)}s\t${expectedChord}\t${entry.chord}\t${matchType.toUpperCase()}\t${entry.confidence.toFixed(0)}%\t${section}\n`;
    });
    
    const avgConfidence = total > 0 ? totalConfidence / total : 0;
    
    report += `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PERFORMANCE METRICS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Average Confidence: ${avgConfidence.toFixed(1)}%
Frame Rate: ${state.fps.toFixed(1)} fps
Total Frames Analyzed: ${state.frameCount}
Detection Speed: ${state.stats.detectionTimes.length > 0 ? 
    (state.stats.detectionTimes.reduce((a, b) => a + b, 0) / 
    state.stats.detectionTimes.length).toFixed(2) + 'ms' : 'N/A'}
Average Harmonic Ratio: ${state.stats.harmonicRatios.length > 0 ? 
    (state.stats.harmonicRatios.reduce((a, b) => a + b, 0) / 
    state.stats.harmonicRatios.length).toFixed(3) : 'N/A'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CHORD VARIATION MAPPING
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Note: The following variations are recognized as equivalent:
- C, Cmaj, CM, Cmaj7, C6, Cadd9 ‚Üí C Major
- G, Gmaj, GM, Gmaj7, G6, Gadd9 ‚Üí G Major
- Em, Emin, Em7, Emin7 ‚Üí E minor
- D, Dmaj, DM, Dmaj7, D6, Dadd9 ‚Üí D Major

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ANALYSIS NOTES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
This report was generated using advanced harmonic analysis
algorithms inspired by Mazmazika, Melodyne, and chords.ai.
The system employs harmonic validation, temporal smoothing,
and tonal context awareness for improved accuracy.

END OF REPORT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;
    
    const blob = new Blob([report], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `TRI_Advanced_Report_${OFFICIAL_PROGRESSION.song.replace(/\s+/g, '_')}_${new Date().getTime()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MOTEUR PRINCIPAL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function initEngine() {
    try {
        if (!state.audioCtx) {
            state.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: CONFIG.sampleRate
            });
            
            state.analyser = state.audioCtx.createAnalyser();
            state.analyser.fftSize = CONFIG.fftSize;
            state.analyser.smoothingTimeConstant = CONFIG.smoothing;
            state.analyser.minDecibels = -100;
            state.analyser.maxDecibels = -30;
            
            state.source = state.audioCtx.createMediaElementSource(UI.player);
            state.source.connect(state.analyser);
            state.analyser.connect(state.audioCtx.destination);
        }
        
        if (state.audioCtx.state === 'suspended') {
            await state.audioCtx.resume();
        }
        
        // Initialiser les composants
        state.chordValidator = new ChordValidator();
        state.keyDetector = new KeyDetector();
        state.harmonicAnalyzer = new HarmonicAnalyzer();
        
        // Mettre √† jour les param√®tres
        state.chordValidator.updateMinDuration(parseFloat(UI.minDurationSlider.value));
        
        state.isRunning = true;
        state.analysisStartTime = performance.now();
        state.lastFrameTime = performance.now();
        
        UI.player.play();
        
        UI.statusDot.classList.add('active');
        UI.statusText.textContent = 'Advanced analysis running...';
        UI.algorithmModeDisplay.textContent = 'Advanced Harmonic';
        UI.bufferSizeDisplay.textContent = CONFIG.fftSize;
        
        // D√©marrer la boucle d'analyse
        analyzeLoop();
        
        console.log('%cüöÄ TRI ULTIMATE v5.4 - Advanced Engine Initialized', 
            'color: #00f0ff; font-size: 16px; font-weight: bold;');
        console.log('%c‚úì Harmonic Detection: Enabled', 'color: #00ff88;');
        console.log('%c‚úì Temporal Smoothing: Enabled', 'color: #00ff88;');
        console.log('%c‚úì Key Context: Enabled', 'color: #00ff88;');
        
    } catch (error) {
        console.error('Engine initialization failed:', error);
        UI.statusText.textContent = 'Initialization failed: ' + error.message;
        UI.statusDot.style.background = 'var(--danger)';
    }
}

function stopEngine() {
    state.isRunning = false;
    UI.player.pause();
    
    UI.statusDot.classList.remove('active');
    UI.statusText.textContent = 'Stopped';
}

function resetEngine() {
    stopEngine();
    
    // R√©initialiser l'√©tat
    state.frameCount = 0;
    state.chordStability = 0;
    state.currentChord = null;
    state.lastChord = null;
    state.chordHistory = [];
    state.keyProfile = new Array(12).fill(0);
    state.correctCount = 0;
    state.partialCount = 0;
    state.wrongCount = 0;
    state.stats = {
        totalChords: 0,
        avgConfidence: 0,
        detectionTimes: [],
        harmonicRatios: []
    };
    
    // R√©initialiser l'UI
    UI.timeline.innerHTML = '';
    UI.chordDisplay.textContent = '--';
    UI.keyDisplay.textContent = '--';
    UI.confFill.style.width = '0%';
    UI.confText.textContent = 'Confidence: 0%';
    UI.progressFill.style.width = '0%';
    UI.analysisProgress.style.width = '0%';
    UI.comparisonTbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #64748b;">Start analysis to see results...</td></tr>';
    
    // R√©initialiser les m√©triques
    UI.energyDisplay.textContent = '0 dB';
    UI.centroidDisplay.textContent = '0 Hz';
    UI.stabilityDisplay.textContent = '0%';
    UI.frameDisplay.textContent = '0';
    UI.tuningOffsetDisplay.textContent = '0¬¢';
    UI.liveAccuracyDisplay.textContent = '0%';
    UI.harmonicRatioDisplay.textContent = '0.0';
    UI.keyConfidenceDisplay.textContent = '0%';
    UI.scaleTypeDisplay.textContent = '--';
    UI.tonicNoteDisplay.textContent = '--';
    UI.strongestNoteDisplay.textContent = '--';
    UI.noteStrengthDisplay.textContent = '0%';
    UI.pitchClarityDisplay.textContent = '0%';
    UI.chordChangesDisplay.textContent = '0';
    UI.avgConfidenceDisplay.textContent = '0%';
    UI.detectionSpeedDisplay.textContent = '0ms';
    UI.timelineLengthDisplay.textContent = '0 chords';
    UI.currentBPMDisplay.textContent = '120';
    UI.currentSectionDisplay.textContent = 'Intro';
    UI.frameRateDisplay.textContent = '0 fps';
    
    console.log('%cüîÑ Engine reset complete', 'color: #ffd60a;');
}

function calibrateEngine() {
    UI.statusText.textContent = 'Calibrating audio analysis...';
    
    // R√©initialiser les param√®tres pour une d√©tection optimale
    CONFIG.harmonicTolerance = 0.008;
    CONFIG.peakThreshold = 0.15;
    CONFIG.minHarmonicCount = 3;
    
    // Mettre √† jour les sliders
    UI.harmonicSensSlider.value = 0.8;
    UI.temporalStabSlider.value = 0.7;
    UI.keyPrioritySlider.value = 2.0;
    UI.minDurationSlider.value = 0.8;
    
    // Mettre √† jour les affichages
    document.getElementById('harmonic-sens-val').textContent = '0.8';
    document.getElementById('temporal-stab-val').textContent = '0.7';
    document.getElementById('key-priority-val').textContent = '2.0x';
    document.getElementById('min-duration-val').textContent = '0.8s';
    
    // Mettre √† jour le validateur
    if (state.chordValidator) {
        state.chordValidator.updateMinDuration(0.8);
    }
    
    setTimeout(() => {
        UI.statusText.textContent = 'Calibration complete - Ready';
        console.log('%cüéöÔ∏è Calibration complete', 'color: #00ff88;');
    }, 1000);
}

// Boucle d'analyse principale
function analyzeLoop() {
    if (!state.isRunning) return;
    
    const startTime = performance.now();
    
    // Calculer le FPS
    const deltaTime = startTime - state.lastFrameTime;
    state.fps = 1000 / deltaTime;
    state.lastFrameTime = startTime;
    
    state.frameCount++;
    
    // Mettre √† jour les m√©triques temporelles
    UI.frameDisplay.textContent = state.frameCount;
    UI.frameRateDisplay.textContent = state.fps.toFixed(1) + ' fps';
    
    const currentTime = UI.player.currentTime;
    UI.timeDisplay.textContent = currentTime.toFixed(2) + 's';
    
    // Mettre √† jour la barre de progression
    if (UI.player.duration > 0) {
        const progressPercent = (currentTime / UI.player.duration) * 100;
        UI.progressFill.style.width = progressPercent + '%';
        UI.analysisProgress.style.width = progressPercent + '%';
    }
    
    // Obtenir les donn√©es spectrales
    const bufferLength = state.analyser.frequencyBinCount;
    const spectrum = new Uint8Array(bufferLength);
    state.analyser.getByteFrequencyData(spectrum);
    
    // D√©tection des fondamentales avanc√©e
    const fundamentals = detectFundamentalsWithHarmonics(spectrum);
    
    // Cr√©er le profil chromatique
    const pitchProfile = createEnhancedPitchProfile(fundamentals, spectrum);
    
    // Analyser les harmoniques
    const sampleRate = state.audioCtx.sampleRate;
    const binWidth = sampleRate / CONFIG.fftSize;
    const harmonicAnalysis = state.harmonicAnalyzer.analyze(fundamentals, spectrum, sampleRate, binWidth);
    
    // Visualiser les harmoniques
    visualizeHarmonics(harmonicAnalysis);
    
    // D√©tection de tonalit√©
    const keyInfo = state.keyDetector.detectKey(pitchProfile);
    if (keyInfo) {
        state.detectedKey = keyInfo.root;
        state.detectedScale = keyInfo.scale;
        state.keyConfidence = keyInfo.confidence;
        
        UI.keyDisplay.textContent = CONFIG.notes[keyInfo.root] + ' ' + keyInfo.scale;
        UI.keyConfidenceDisplay.textContent = (keyInfo.confidence * 10).toFixed(0) + '%';
        UI.scaleTypeDisplay.textContent = keyInfo.scale;
        UI.tonicNoteDisplay.textContent = CONFIG.notes[keyInfo.root];
    }
    
    // D√©tection d'accord avec contexte
    const chordDetection = detectChordWithContext(pitchProfile, keyInfo);
    const bestChord = chordDetection.best;
    
    // Calculer la confiance
    const totalEnergy = pitchProfile.reduce((a, b) => a + b, 0);
    const confidence = totalEnergy > 0 ? 
        Math.min(100, (bestChord.score / totalEnergy) * 180) : 0;
    
    // Mettre √† jour l'affichage de confiance
    UI.confFill.style.width = confidence + '%';
    UI.confText.textContent = 'Confidence: ' + confidence.toFixed(1) + '%';
    
    // Validation et enregistrement de l'accord
    const shouldRegister = state.chordValidator.validateChange(
        bestChord.name,
        currentTime,
        confidence
    );
    
    if (shouldRegister && confidence > 40) {
        // Mettre √† jour l'affichage
        UI.chordDisplay.textContent = bestChord.name;
        
        // Ajouter √† la timeline
        addToTimeline(bestChord.name, currentTime, confidence);
        
        // Mettre √† jour la stabilit√©
        if (bestChord.name === state.lastChord) {
            state.chordStability++;
        } else {
            state.chordStability = 0;
            state.lastChord = bestChord.name;
        }
        
        // Mettre √† jour l'affichage de stabilit√©
        const stabilityPercent = Math.min(100, (state.chordStability / CONFIG.stabilityThreshold) * 100);
        UI.stabilityDisplay.textContent = stabilityPercent.toFixed(0) + '%';
    }
    
    // Mettre √† jour la section actuelle
    const expected = getExpectedChord(currentTime);
    if (expected) {
        UI.currentSectionDisplay.textContent = expected.section;
    }
    
    // Calculer le centroid spectral
    let centroid = 0;
    let totalMag = 0;
    for (let i = 0; i < spectrum.length; i++) {
        const freq = i * (sampleRate / CONFIG.fftSize);
        centroid += freq * spectrum[i];
        totalMag += spectrum[i];
    }
    centroid = totalMag > 0 ? centroid / totalMag : 0;
    
    // Calculer l'√©nergie RMS
    let sumSquares = 0;
    for (let i = 0; i < spectrum.length; i++) {
        sumSquares += Math.pow(spectrum[i] / 255, 2);
    }
    const rms = Math.sqrt(sumSquares / spectrum.length);
    const energyDB = 20 * Math.log10(rms + 0.0001);
    
    // Mettre √† jour les affichages
    UI.energyDisplay.textContent = energyDB.toFixed(1) + ' dB';
    UI.centroidDisplay.textContent = centroid.toFixed(0) + ' Hz';
    
    // Stocker les m√©triques de performance
    const endTime = performance.now();
    const detectionTime = endTime - startTime;
    state.stats.detectionTimes.push(detectionTime);
    state.stats.harmonicRatios.push(state.harmonicAnalyzer.getHarmonicRatio());
    
    // Limiter la taille des historiques de m√©triques
    if (state.stats.detectionTimes.length > 100) {
        state.stats.detectionTimes.shift();
        state.stats.harmonicRatios.shift();
    }
    
    // Calculer la vitesse moyenne de d√©tection
    const avgDetectionTime = state.stats.detectionTimes.length > 0 ?
        state.stats.detectionTimes.reduce((a, b) => a + b, 0) / state.stats.detectionTimes.length : 0;
    UI.detectionSpeedDisplay.textContent = avgDetectionTime.toFixed(1) + 'ms';
    
    // Visualisations
    drawSpectrum(spectrum);
    updateChromagram(pitchProfile);
    
    // Continuer la boucle
    requestAnimationFrame(analyzeLoop);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// √âCOUTEURS D'√âV√âNEMENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Chargement audio
document.getElementById('audio-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        UI.player.src = URL.createObjectURL(file);
        UI.statusText.textContent = 'Audio loaded: ' + file.name;
    }
});

// Contr√¥les
document.getElementById('start-btn').addEventListener('click', initEngine);
document.getElementById('validate-btn').addEventListener('click', validateResults);
document.getElementById('export-btn').addEventListener('click', exportReport);
document.getElementById('stop-btn').addEventListener('click', stopEngine);
document.getElementById('reset-btn').addEventListener('click', resetEngine);
document.getElementById('calibrate-btn').addEventListener('click', calibrateEngine);

// Sliders
UI.harmonicSensSlider.addEventListener('input', (e) => {
    document.getElementById('harmonic-sens-val').textContent = e.target.value;
});

UI.temporalStabSlider.addEventListener('input', (e) => {
    document.getElementById('temporal-stab-val').textContent = e.target.value;
});

UI.keyPrioritySlider.addEventListener('input', (e) => {
    document.getElementById('key-priority-val').textContent = e.target.value + 'x';
});

UI.minDurationSlider.addEventListener('input', (e) => {
    document.getElementById('min-duration-val').textContent = e.target.value + 's';
    if (state.chordValidator) {
        state.chordValidator.updateMinDuration(parseFloat(e.target.value));
    }
});

// Mise √† jour de la progression audio
UI.player.addEventListener('timeupdate', () => {
    if (UI.player.duration > 0) {
        const progress = (UI.player.currentTime / UI.player.duration) * 100;
        UI.progressFill.style.width = progress + '%';
    }
});

// Initialisation
console.log('%cüéµ TRI ULTIMATE v5.4 - Advanced Chord Recognition', 
    'color: #00f0ff; font-size: 18px; font-weight: bold;');
console.log('%cInspired by Mazmazika, Melodyne, and chords.ai algorithms', 
    'color: #ffd60a;');
console.log('%cReady for advanced harmonic analysis', 'color: #00ff88;');

</script>
</body>
</html>